window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "src", "modulename": "src", "kind": "module", "doc": "<h1 id=\"\u03c8\u03c0-psipy-symbolic-numerical-toolkit-for-pdes-and-hamiltonian-mechanics\">\u03a8\u03c0 (psipy): Symbolic-Numerical Toolkit for PDEs and Hamiltonian Mechanics</h1>\n\n<h2 id=\"overview\">Overview</h2>\n\n<p>Welcome to <code>psipy</code>, a comprehensive Python ecosystem designed to bridge the gap\nbetween formal symbolic mathematics (via SymPy) and high-performance numerical\nsimulation (via NumPy/SciPy). This library provides a unified framework for\ndefining, analyzing, solving, and visualizing complex problems in:</p>\n\n<ul>\n<li>Partial Differential Equations (PDEs)</li>\n<li>Pseudo-Differential Operators (\u03a8DOs)</li>\n<li>Hamiltonian and Lagrangian Mechanics</li>\n<li>Semiclassical and Microlocal Analysis</li>\n</ul>\n\n<p>The core philosophy is to allow users to move seamlessly from a formal symbolic\ndefinition\u2014such as a Lagrangian, a Hamiltonian from the included catalog, or a\nPDE written in SymPy\u2014to a robust numerical analysis, such as solving the PDE's\nevolution, visualizing its phase-space geometry, or computing its semiclassical\nspectrum.</p>\n\n<h2 id=\"core-components\">Core Components</h2>\n\n<p>The <code>psipy</code> ecosystem is composed of several powerful, interoperable modules:</p>\n\n<ul>\n<li><p><strong><code>PDESolver</code></strong>: The main numerical engine. It parses symbolic PDEs and solves\n1D/2D, linear/nonlinear, time-dependent or stationary equations. It uses spectral\n(FFT) methods with high-order exponential integrators (like ETD-RK4) for robust\ntime evolution.</p></li>\n<li><p><strong><code>PseudoDifferentialOperator</code></strong>: A complete symbolic and numerical framework for Pseudo-Differential\nOperators (\u03a8DOs). It supports symbolic calculus (composition, commutators, adjoints)\nand microlocal analysis (ellipticity, characteristic sets), bridging formal definitions\nwith numerical evaluation on grids.</p></li>\n<li><p><strong><code>LagrangianHamiltonianConverter</code> &amp; <code>HamiltonianSymbolicConverter</code></strong>: A symbolic toolkit for analytical mechanics. It performs purely\nsymbolic Legendre transforms (L \u2194 H) and can automatically generate formal symbolic\nPDEs (e.g., Schr\u00f6dinger, Wave) from any given Hamiltonian symbol.</p></li>\n<li><p><strong><code>HamiltonianCatalog</code></strong>: A vast, curated, and searchable symbolic database of\n<strong>over 500</strong> Hamiltonian systems. It spans classical mechanics, quantum chaos,\nbiophysics, and more, providing a rich testbed for research and education.</p></li>\n<li><p><strong><code>SymbolGeometry</code></strong>: A comprehensive analysis and visualization suite for 1D\nHamiltonian systems. It connects classical geometry to quantum spectra by computing\nclassical trajectories, periodic orbits, and the semiclassical energy spectrum via\nthe <strong>Gutzwiller trace formula</strong> and <strong>EBK quantization</strong>.</p></li>\n<li><p><strong><code>SymbolGeometry2D</code></strong>: An advanced 2D analysis toolkit for visualizing dynamical\nsystems. It performs rigorous <strong>caustic detection</strong> by tracking the full 4x4 Jacobian,\ngenerates <strong>Poincar\u00e9 sections</strong>, and analyzes <strong>KAM tori</strong>, providing a deep dive\ninto 2D phase space geometry.</p></li>\n</ul>\n\n<h2 id=\"typical-workflow\">Typical Workflow</h2>\n\n<p>A common use case involves combining all modules:</p>\n\n<ol>\n<li><p><strong>Select a System</strong>: Fetch a complex Hamiltonian (e.g., \"henon_heiles\")\nfrom the <code>HamiltonianCatalog</code>.</p></li>\n<li><p><strong>Formulate the PDE</strong>: Use <code>SymPhysics</code> to automatically generate the\ncorresponding symbolic Schr\u00f6dinger equation.</p></li>\n<li><p><strong>Analyze Geometry</strong>: Pass the Hamiltonian symbol to <code>SymbolGeometry2D</code>\nto visualize its classical trajectories, Poincar\u00e9 sections, and chaotic regions.</p></li>\n<li><p><strong>Solve Dynamics</strong>: Pass the symbolic PDE to the <code>PDESolver</code> to\nsimulate the quantum wave function's evolution in time.</p></li>\n</ol>\n\n<h2 id=\"example-solving-a-pseudo-differential-pde\">Example: Solving a Pseudo-Differential PDE</h2>\n\n<p>This example defines a 1D Schr\u00f6dinger-type equation with a non-local,\nrelativistic kinetic term, i \u2202\u209c u = \u221a(1 - \u2202\u2093\u00b2) u.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">solver</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"c1\"># 1. Define symbolic variables</span>\n<span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">xi</span> <span class=\"o\">=</span> <span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s1\">&#39;t x xi&#39;</span><span class=\"p\">,</span> <span class=\"n\">real</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">u</span> <span class=\"o\">=</span> <span class=\"n\">Function</span><span class=\"p\">(</span><span class=\"s1\">&#39;u&#39;</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># 2. Define the PDE symbolically</span>\n<span class=\"c1\"># The symbol for the operator \u221a(1 - \u2202\u2093\u00b2) is p(\u03be) = \u221a(1 + \u03be\u00b2)</span>\n<span class=\"c1\"># (using the Fourier convention p(\u03be) \u2192 op(\u03be) \u2192 -\u2202\u2093\u00b2)</span>\n<span class=\"n\">p_symbol</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">xi</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># The equation is: i * \u2202\u209c u = psiOp(p_symbol) * u</span>\n<span class=\"n\">equation</span> <span class=\"o\">=</span> <span class=\"n\">Eq</span><span class=\"p\">(</span><span class=\"n\">I</span> <span class=\"o\">*</span> <span class=\"n\">diff</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">),</span> <span class=\"n\">t</span><span class=\"p\">),</span> <span class=\"n\">psiOp</span><span class=\"p\">(</span><span class=\"n\">p_symbol</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">)))</span>\n\n<span class=\"c1\"># 3. Create the solver</span>\n<span class=\"n\">solver</span> <span class=\"o\">=</span> <span class=\"n\">PDESolver</span><span class=\"p\">(</span><span class=\"n\">equation</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># 4. Setup the simulation domain and initial condition</span>\n<span class=\"n\">initial_packet</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">/</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"n\">j</span> <span class=\"o\">*</span> <span class=\"mf\">5.0</span> <span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"n\">solver</span><span class=\"o\">.</span><span class=\"n\">setup</span><span class=\"p\">(</span>\n    <span class=\"n\">Lx</span><span class=\"o\">=</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"p\">,</span> <span class=\"n\">Nx</span><span class=\"o\">=</span><span class=\"mi\">256</span><span class=\"p\">,</span>\n    <span class=\"n\">Lt</span><span class=\"o\">=</span><span class=\"mf\">4.0</span><span class=\"p\">,</span> <span class=\"n\">Nt</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">,</span>\n    <span class=\"n\">initial_condition</span><span class=\"o\">=</span><span class=\"n\">initial_packet</span><span class=\"p\">,</span>\n    <span class=\"n\">boundary_condition</span><span class=\"o\">=</span><span class=\"s1\">&#39;periodic&#39;</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># 5. Solve the PDE</span>\n<span class=\"n\">solver</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># 6. Animate the solution</span>\n<span class=\"n\">ani</span> <span class=\"o\">=</span> <span class=\"n\">solver</span><span class=\"o\">.</span><span class=\"n\">animate</span><span class=\"p\">()</span>\n<span class=\"n\">HTML</span><span class=\"p\">(</span><span class=\"n\">ani</span><span class=\"o\">.</span><span class=\"n\">to_jshtml</span><span class=\"p\">())</span>\n</code></pre>\n</div>\n"}, {"fullname": "src.PseudoDifferentialOperator", "modulename": "src", "qualname": "PseudoDifferentialOperator", "kind": "class", "doc": "<p>Pseudo-differential operator with dynamic symbol evaluation on spatial grids.\nSupports both 1D and 2D operators, and can be defined explicitly (symbol mode)\nor extracted automatically from symbolic equations (auto mode).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>expr : sympy expression\n    Symbolic expression representing the pseudo-differential symbol.\nvars_x : list of sympy symbols\n    Spatial variables (e.g., [x] for 1D, [x, y] for 2D).\nvar_u : sympy function, optional\n    Function u(x, t) used in auto mode to extract the operator symbol.\nmode : str, {'symbol', 'auto'}\n    - 'symbol': directly uses expr as the operator symbol.\n    - 'auto': computes the symbol automatically by applying expr to exp(i x \u03be).</p>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>dim : int\n    Spatial dimension (1 or 2).\nfft, ifft : callable\n    Fast Fourier transform and inverse (scipy.fft or scipy.fft2).\np_func : callable\n    Evaluated symbol function ready for numerical use.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>In 'symbol' mode, <code>expr</code> should be expressed in terms of spatial variables and frequency variables (\u03be, \u03b7).</li>\n<li>In 'auto' mode, the symbol is derived by applying the differential expression to a complex exponential.</li>\n<li>Frequency variables are internally named 'xi' and 'eta' for consistency.</li>\n<li>Uses numpy for numerical evaluation and scipy.fft for FFT operations.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Example 1: 1D Laplacian operator (symbol mode)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">sympy</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">symbols</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">xi</span> <span class=\"o\">=</span> <span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s1\">&#39;x xi&#39;</span><span class=\"p\">,</span> <span class=\"n\">real</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">PseudoDifferentialOperator</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"n\">xi</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">vars_x</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">],</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;symbol&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Example 2: 1D transport operator (auto mode)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">sympy</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Function</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">u</span> <span class=\"o\">=</span> <span class=\"n\">Function</span><span class=\"p\">(</span><span class=\"s1\">&#39;u&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">expr</span> <span class=\"o\">=</span> <span class=\"n\">u</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">diff</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">PseudoDifferentialOperator</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"o\">=</span><span class=\"n\">expr</span><span class=\"p\">,</span> <span class=\"n\">vars_x</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">],</span> <span class=\"n\">var_u</span><span class=\"o\">=</span><span class=\"n\">u</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">),</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;auto&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}, {"fullname": "src.PseudoDifferentialOperator.__init__", "modulename": "src", "qualname": "PseudoDifferentialOperator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">expr</span>, </span><span class=\"param\"><span class=\"n\">vars_x</span>, </span><span class=\"param\"><span class=\"n\">var_u</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;symbol&#39;</span></span>)</span>"}, {"fullname": "src.PseudoDifferentialOperator.dim", "modulename": "src", "qualname": "PseudoDifferentialOperator.dim", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PseudoDifferentialOperator.mode", "modulename": "src", "qualname": "PseudoDifferentialOperator.mode", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PseudoDifferentialOperator.symbol_cached", "modulename": "src", "qualname": "PseudoDifferentialOperator.symbol_cached", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PseudoDifferentialOperator.expr", "modulename": "src", "qualname": "PseudoDifferentialOperator.expr", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PseudoDifferentialOperator.vars_x", "modulename": "src", "qualname": "PseudoDifferentialOperator.vars_x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PseudoDifferentialOperator.evaluate", "modulename": "src", "qualname": "PseudoDifferentialOperator.evaluate", "kind": "function", "doc": "<p>Evaluate the pseudo-differential operator's symbol on a grid of spatial and frequency coordinates.</p>\n\n<p>The method dynamically selects between 1D and 2D evaluation based on the spatial dimension.\nIf caching is enabled and a cached symbol exists, it returns the cached result to avoid recomputation.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X, Y : ndarray\n    Spatial grid coordinates. In 1D, Y is ignored.\nKX, KY : ndarray\n    Frequency grid coordinates. In 1D, KY is ignored.\ncache : bool, default=True\n    If True, stores the computed symbol for reuse in subsequent calls to avoid redundant computation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    Evaluated symbol values over the input grid. Shape matches the input spatial/frequency grids.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>NotImplementedError\n    If the spatial dimension is not 1D or 2D.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Y</span>, </span><span class=\"param\"><span class=\"n\">KX</span>, </span><span class=\"param\"><span class=\"n\">KY</span>, </span><span class=\"param\"><span class=\"n\">cache</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.clear_cache", "modulename": "src", "qualname": "PseudoDifferentialOperator.clear_cache", "kind": "function", "doc": "<p>Clear cached symbol evaluations.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.apply", "modulename": "src", "qualname": "PseudoDifferentialOperator.apply", "kind": "function", "doc": "<p>Apply the pseudo-differential operator to the input field u.</p>\n\n<p>This method dispatches the application of the pseudo-differential operator based on:</p>\n\n<ul>\n<li>Whether the symbol is spatially dependent (x/y)</li>\n<li>The boundary condition in use (periodic or dirichlet)</li>\n</ul>\n\n<p>Supported operations:</p>\n\n<ul>\n<li>Constant-coefficient symbols: applied via Fourier multiplication.</li>\n<li>Spatially varying symbols: applied via Kohn\u2013Nirenberg quantization.</li>\n<li>Dirichlet boundary conditions: handled with non-periodic convolution-like quantization.</li>\n</ul>\n\n<p>Dispatch Logic:</p>\n\n<p>if not self.is_spatial: u \u21a6 Op(p)(D) \u22c5 u = \ud835\udcd5\u207b\u00b9[ p(\u03be) \u22c5 \ud835\udcd5(u) ]</p>\n\n<p>elif periodic: u \u21a6 Op(p)(x,D) \u22c5 u \u2248 \u222b e\u1da6\u02e3\u1dbf p(x, \u03be) \ud835\udcd5(u)(\u03be) d\u03be based of FFT (quicker)</p>\n\n<p>elif dirichlet: u \u21a6 Op(p)(x,D) \u22c5 u \u2248 u \u2248 \u222b e\u1da6\u02e3\u1dbf p(x, \u03be) \ud835\udcd5(u)(\u03be) d\u03be (slower)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>u : ndarray\n    Function to which the operator is applied\nx_grid : ndarray\n    Spatial grid in x direction\nkx : ndarray\n    Frequency grid in x direction\nboundary_condition : str\n    'periodic' or 'dirichlet'\ny_grid : ndarray, optional\n    Spatial grid in y direction (for 2D)\nky : ndarray, optional\n    Frequency grid in y direction (for 2D)\ndealiasing_mask : ndarray, optional\n    Dealiasing mask\nfreq_window : str\n    Frequency windowing ('gaussian' or 'hann')\nclamp : float\n    Clamp symbol values to [-clamp, clamp]\nspace_window : bool\n    Apply spatial windowing</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    Result of applying the operator</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">u</span>,</span><span class=\"param\">\t<span class=\"n\">x_grid</span>,</span><span class=\"param\">\t<span class=\"n\">kx</span>,</span><span class=\"param\">\t<span class=\"n\">boundary_condition</span><span class=\"o\">=</span><span class=\"s1\">&#39;periodic&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">y_grid</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ky</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dealiasing_mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">freq_window</span><span class=\"o\">=</span><span class=\"s1\">&#39;gaussian&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">clamp</span><span class=\"o\">=</span><span class=\"mf\">1000000.0</span>,</span><span class=\"param\">\t<span class=\"n\">space_window</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.principal_symbol", "modulename": "src", "qualname": "PseudoDifferentialOperator.principal_symbol", "kind": "function", "doc": "<p>Compute the leading homogeneous component of the pseudo-differential symbol.</p>\n\n<p>This method extracts the principal part of the symbol, which is the dominant \nterm under high-frequency asymptotics (|\u03be| \u2192 \u221e). The expansion is performed \nin polar coordinates for 2D symbols to maintain rotational symmetry, then \nconverted back to Cartesian form.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>order : int\n    Order of the asymptotic expansion in powers of 1/\u03c1, where \u03c1 = |\u03be| in 1D \n    or \u03c1 = sqrt(\u03be\u00b2 + \u03b7\u00b2) in 2D. Only the leading-order term is returned.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sympy.Expr\n    The principal symbol component, homogeneous of degree <code>m - order</code>, where \n    <code>m</code> is the original symbol's order.</p>\n\n<p>Notes:</p>\n\n<ul>\n<li>In 1D, uses direct series expansion in \u03be.</li>\n<li>In 2D, expands in radial variable \u03c1 while preserving angular dependence.</li>\n<li>Useful for microlocal analysis and constructing parametrices.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.is_homogeneous", "modulename": "src", "qualname": "PseudoDifferentialOperator.is_homogeneous", "kind": "function", "doc": "<p>Check whether the symbol is homogeneous in the frequency variables.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(bool, Rational or float or None)\n    Tuple (is_homogeneous, degree) where:\n    - is_homogeneous: True if the symbol satisfies p(\u03bb\u03be, \u03bb\u03b7) = \u03bb^m * p(\u03be, \u03b7)\n    - degree: the detected degree m if homogeneous, or None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-10</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.symbol_order", "modulename": "src", "qualname": "PseudoDifferentialOperator.symbol_order", "kind": "function", "doc": "<p>Estimate the homogeneity order of the pseudo-differential symbol in high-frequency asymptotics.</p>\n\n<p>This method attempts to determine the leading-order behavior of the symbol p(x, \u03be) or p(x, y, \u03be, \u03b7)\nas |\u03be| \u2192 \u221e (in 1D) or |(\u03be, \u03b7)| \u2192 \u221e (in 2D). The returned value represents the asymptotic growth or decay rate,\nwhich is essential for understanding the regularity and mapping properties of the corresponding operator.</p>\n\n<p>The function uses symbolic preprocessing to ensure proper factorization of frequency variables,\nespecially in sqrt and power expressions, to avoid erroneous order detection (e.g., due to hidden scaling).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>max_order : int, optional\n    Maximum number of terms to consider in the series expansion. Default is 10.\ntol : float, optional\n    Tolerance threshold for evaluating the coefficient magnitude. If the coefficient is too small,\n    the detected order may be discarded. Default is 1e-3.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float or None\n    - If the symbol is homogeneous, returns its exact homogeneity degree as a float.\n    - Otherwise, estimates the dominant asymptotic order from leading terms in the expansion.\n    - Returns None if no valid order could be determined.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li><p>In 1D:\nTwo strategies are used:\n    1. Expand directly in xi at infinity.\n    2. Substitute xi = 1/z and expand around z = 0.</p></li>\n<li><p>In 2D:</p>\n\n<ul>\n<li>Transform the symbol into polar coordinates: (xi, eta) = rho*(cos(theta), sin(theta)).</li>\n<li>Expand in rho at infinity, then extract the leading term's power.</li>\n<li>An alternative substitution using 1/z is also tried if the first method fails.</li>\n</ul></li>\n<li><p>Preprocessing steps:</p>\n\n<ul>\n<li>Sqrt expressions involving frequencies are rewritten to isolate the leading variable.</li>\n<li>Power expressions are factored explicitly to ensure correct symbolic scaling.</li>\n</ul></li>\n<li><p>If the symbol is not homogeneous, a warning is issued, and the result should be interpreted with care.</p></li>\n<li><p>For non-homogeneous symbols, only the principal asymptotic term is considered.</p></li>\n</ul>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>NotImplementedError\n    If the spatial dimension is neither 1 nor 2.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">max_order</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">0.001</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.asymptotic_expansion", "modulename": "src", "qualname": "PseudoDifferentialOperator.asymptotic_expansion", "kind": "function", "doc": "<p>Compute the asymptotic expansion of the symbol as |\u03be| \u2192 \u221e (high-frequency regime).</p>\n\n<p>This method expands the pseudo-differential symbol in inverse powers of the \nfrequency variable(s), either in 1D or 2D. It handles both polynomial and \nexponential symbols by performing a series expansion in 1/|\u03be| up to the specified order.</p>\n\n<p>The expansion is performed directly in Cartesian coordinates for 1D symbols.\nFor 2D symbols, the method uses polar coordinates (\u03c1, \u03b8) to perform the expansion \nat infinity in \u03c1, then converts the result back to Cartesian coordinates.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>order : int, optional\n    Maximum order of the asymptotic expansion. Default is 3.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sympy.Expr\n    The asymptotic expansion of the symbol up to the given order, expressed in Cartesian coordinates.\n    If expansion fails, returns the original unexpanded symbol.</p>\n\n<p>Notes:</p>\n\n<ul>\n<li>In 1D: expansion is performed directly in terms of \u03be.</li>\n<li>In 2D: the symbol is first rewritten in polar coordinates (\u03c1,\u03b8), expanded asymptotically \nin \u03c1 \u2192 \u221e, then converted back to Cartesian coordinates (\u03be,\u03b7).</li>\n<li>Handles special case when the symbol is an exponential function by expanding its argument.</li>\n<li>Symbolic normalization is applied early (via <code>simplify</code>) for 2D expressions to improve convergence.</li>\n<li>Robust to failures: catches exceptions and issues warnings instead of raising errors.</li>\n<li>Final expression is simplified using <code>powdenest</code> and <code>expand</code> for improved readability.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.compose_asymptotic", "modulename": "src", "qualname": "PseudoDifferentialOperator.compose_asymptotic", "kind": "function", "doc": "<p>Compose two pseudo-differential operators using an asymptotic expansion\nin the chosen quantization scheme (Kohn\u2013Nirenberg or Weyl).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>other : PseudoDifferentialOperator\n    The operator to compose with this one.\norder : int, default=1\n    Maximum order of the asymptotic expansion.\nmode : {'kn', 'weyl'}, default='kn'\n    Quantization mode:\n    - 'kn' : Kohn\u2013Nirenberg quantization (left-quantized)\n    - 'weyl' : Weyl symmetric quantization\nsign_convention : {'standard', 'inverse'}, optional\n    Controls the phase factor convention for the KN case:\n    - 'standard' \u2192 (i)^(-n), gives [x, \u03be] = +i (physics convention)\n    - 'inverse' \u2192 (i)^(+n), gives [x, \u03be] = -i (mathematical adjoint convention)\n    If None, defaults to 'standard'.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sympy.Expr\n    Symbolic expression for the composed symbol up to the given order.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>In 1D (Kohn\u2013Nirenberg):\n(p \u2218 q)(x, \u03be) ~ \u03a3\u2099 (1/n!) (i sgn)^n \u2202_\u03be\u207f p(x, \u03be) \u2202_x\u207f q(x, \u03be)</li>\n<li>In 1D (Weyl):\n(p # q)(x, \u03be) = exp[(i/2)(\u2202_\u03be^p \u2202_x^q - \u2202_x^p \u2202_\u03be^q)] p(x, \u03be) q(x, \u03be)\ntruncated at given order.</li>\n</ul>\n\n<h2 id=\"examples\">Examples</h2>\n\n<p>X = a<em>x, Y = b</em>\u03be\nX_op.compose_asymptotic(Y_op, order=3, mode='weyl')</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;kn&#39;</span>, </span><span class=\"param\"><span class=\"n\">sign_convention</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.commutator_symbolic", "modulename": "src", "qualname": "PseudoDifferentialOperator.commutator_symbolic", "kind": "function", "doc": "<p>Compute the symbolic commutator [A, B] = A\u2218B \u2212 B\u2218A of two pseudo-differential operators\nusing formal asymptotic expansion of their composition symbols.</p>\n\n<p>This method computes the asymptotic expansion of the commutator's symbol up to a given \norder, based on the symbolic calculus of pseudo-differential operators in the \nKohn\u2013Nirenberg quantization. The result is a purely symbolic sympy expression that \ncaptures the leading-order noncommutativity of the operators.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>other : PseudoDifferentialOperator\n    The pseudo-differential operator B to commute with this operator A.\norder : int, default=1\n    Maximum order of the asymptotic expansion. \n    - order=1 yields the leading term proportional to the Poisson bracket {p, q}.\n    - Higher orders include correction terms involving higher mixed derivatives.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sympy.Expr\n    Symbolic expression for the asymptotic expansion of the commutator symbol \n    \u03c3([A,B]) = \u03c3(A\u2218B \u2212 B\u2218A).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;kn&#39;</span>, </span><span class=\"param\"><span class=\"n\">sign_convention</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.right_inverse_asymptotic", "modulename": "src", "qualname": "PseudoDifferentialOperator.right_inverse_asymptotic", "kind": "function", "doc": "<p>Construct a formal right inverse R of the pseudo-differential operator P such that \nthe composition P \u2218 R equals the identity plus a smoothing operator of order -order.</p>\n\n<p>This method computes an asymptotic expansion for the right inverse using recursive \ncorrections based on derivatives of the symbol p(x, \u03be) and lower-order terms of R.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>order : int\n    Number of terms to include in the asymptotic expansion. Higher values improve \n    approximation at the cost of complexity and computational effort.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sympy.Expr\n    The symbolic expression representing the formal right inverse R(x, \u03be), which satisfies:\n    P \u2218 R = Id + O(\u27e8\u03be\u27e9^{-order}), where \u27e8\u03be\u27e9 = (1 + |\u03be|\u00b2)^{1/2}.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>In 1D: The recursion involves spatial derivatives of R and derivatives of p with respect to \u03be.</li>\n<li>In 2D: The multi-index generalization is used with mixed derivatives in \u03be and \u03b7.</li>\n<li>The construction relies on the non-vanishing of the principal symbol p to ensure invertibility.</li>\n<li>Each term in the expansion corresponds to higher-order corrections involving commutators \nbetween the operator P and the current approximation of R.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.left_inverse_asymptotic", "modulename": "src", "qualname": "PseudoDifferentialOperator.left_inverse_asymptotic", "kind": "function", "doc": "<p>Construct a formal left inverse L such that the composition L \u2218 P equals the identity \noperator up to terms of order \u03be^{-order}. This expansion is performed asymptotically \nat infinity in the frequency variable(s).</p>\n\n<p>The left inverse is built iteratively using symbolic differentiation and the \nmethod of asymptotic expansions for pseudo-differential operators. It ensures that:</p>\n\n<pre><code>L(P(x,\u03be),x,D) \u2218 P(x,D) = Id + smoothing operator of order -order\n</code></pre>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>order : int, optional\n    Maximum number of terms in the asymptotic expansion (default is 1). Higher values \n    yield more accurate inverses at the cost of increased computational complexity.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sympy.Expr\n    Symbolic expression representing the principal symbol of the formal left inverse \n    operator L(x,\u03be). This expression depends on spatial variables and frequencies, \n    and includes correction terms up to the specified order.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>In 1D: Uses recursive application of the Leibniz formula for symbols.</li>\n<li>In 2D: Generalizes to multi-indices for mixed derivatives in (x,y) and (\u03be,\u03b7).</li>\n<li>Each term involves combinations of derivatives of the original symbol p(x,\u03be) and \npreviously computed terms of the inverse.</li>\n<li>Coefficients include powers of 1j (i) and factorial normalization for derivative terms.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.formal_adjoint", "modulename": "src", "qualname": "PseudoDifferentialOperator.formal_adjoint", "kind": "function", "doc": "<p>Compute the formal adjoint symbol P* of the pseudo-differential operator.</p>\n\n<p>The adjoint is defined such that for any test functions u and v,\n\u27e8P u, v\u27e9 = \u27e8u, P* v\u27e9 holds in the distributional sense. This is obtained by \ntaking the complex conjugate of the symbol and expanding it asymptotically \nat infinity to ensure proper behavior under integration by parts.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sympy.Expr\n    The adjoint symbol P<em>(x, \u03be) in 1D or P</em>(x, y, \u03be, \u03b7) in 2D.</p>\n\n<p>Notes:</p>\n\n<ul>\n<li>In 1D, the expansion is performed in powers of 1/|\u03be|.</li>\n<li>In 2D, the expansion is radial in |\u03be| = sqrt(\u03be\u00b2 + \u03b7\u00b2).</li>\n<li>This method ensures symbolic simplifications for readability and efficiency.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.exponential_symbol", "modulename": "src", "qualname": "PseudoDifferentialOperator.exponential_symbol", "kind": "function", "doc": "<p>Compute the symbol of exp(tP) using asymptotic expansion methods.</p>\n\n<p>This method calculates the exponential of a pseudo-differential operator \nusing either a direct power series expansion or a Magnus expansion, \ndepending on the structure of the symbol. The result is valid up to \nthe specified asymptotic order.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>t : float or sympy.Symbol, default=1.0\n    Time or evolution parameter. Common uses:\n    - t = -i*\u03c4 for Schr\u00f6dinger evolution: exp(-i\u03c4H)\n    - t = \u03c4 for heat/diffusion: exp(\u03c4\u0394)\n    - t for general propagators\norder : int, default=3\n    Maximum order of the asymptotic expansion. Higher orders include \n    more composition terms, improving accuracy for small t or when \n    non-commutativity effects are significant.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sympy.Expr\n    Symbolic expression for the exponential operator symbol, computed \n    as an asymptotic series up to the specified order.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li><p>For commutative symbols (e.g., pure multiplication operators), the \nexponential is exact: exp(tP) = exp(t*p(x,\u03be)).</p></li>\n<li><p>For general non-commutative operators, the method uses the BCH-type \nexpansion via iterated composition:\nexp(tP) ~ I + tP + (t\u00b2/2!)P\u2218P + (t\u00b3/3!)P\u2218P\u2218P + ...</p></li>\n<li><p>Each power P^n is computed via compose_asymptotic, which accounts \nfor the non-commutativity through derivative terms.</p></li>\n<li><p>The expansion is valid for |t| small enough or when the symbol has \nappropriate decay/growth properties.</p></li>\n<li><p>In quantum mechanics (Schr\u00f6dinger): U(t) = exp(-itH/\u210f) represents \nthe time evolution operator.</p></li>\n<li><p>In parabolic PDEs (heat equation): exp(t\u0394) is the heat kernel.</p></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;kn&#39;</span>, </span><span class=\"param\"><span class=\"n\">sign_convention</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.trace_formula", "modulename": "src", "qualname": "PseudoDifferentialOperator.trace_formula", "kind": "function", "doc": "<p>Compute the semiclassical trace of the pseudo-differential operator.</p>\n\n<p>The trace formula relates the quantum trace of an operator to a \nphase-space integral of its symbol, providing a fundamental link \nbetween classical and quantum mechanics. This implementation supports \nboth symbolic and numerical integration.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>volume_element : sympy.Expr, optional\n    Custom volume element for the phase space integration. If None, \n    uses the standard Liouville measure dx d\u03be/(2\u03c0)^d.\nnumerical : bool, default=False\n    If True, perform numerical integration over specified bounds.\n    If False, attempt symbolic integration (may fail for complex symbols).\nx_bounds : tuple of tuples, optional\n    Spatial integration bounds. For 1D: ((x_min, x_max),)\n    For 2D: ((x_min, x_max), (y_min, y_max))\n    Required if numerical=True.\nxi_bounds : tuple of tuples, optional\n    Frequency integration bounds. For 1D: ((xi_min, xi_max),)\n    For 2D: ((xi_min, xi_max), (eta_min, eta_max))\n    Required if numerical=True.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sympy.Expr or float\n    The trace of the operator. Returns a symbolic expression if \n    numerical=False, or a float if numerical=True.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li><p>The semiclassical trace formula states:\nTr(P) = (2\u03c0)^{-d} \u222b\u222b p(x,\u03be) dx d\u03be\nwhere d is the spatial dimension and p(x,\u03be) is the operator symbol.</p></li>\n<li><p>For 1D: Tr(P) = (1/2\u03c0) \u222b_{-\u221e}^{\u221e} \u222b_{-\u221e}^{\u221e} p(x,\u03be) dx d\u03be</p></li>\n<li><p>For 2D: Tr(P) = (1/4\u03c0\u00b2) \u222b\u222b\u222b\u222b p(x,y,\u03be,\u03b7) dx dy d\u03be d\u03b7</p></li>\n<li><p>This formula is exact for trace-class operators and provides an \nasymptotic approximation for general pseudo-differential operators.</p></li>\n<li><p>Physical interpretation: the trace counts the \"number of states\" \nweighted by the observable p(x,\u03be).</p></li>\n<li><p>For projection operators (\u03c7_\u03a9 with \u03c7\u00b2 = \u03c7), the trace gives the \ndimension of the range, related to the phase space volume of \u03a9.</p></li>\n<li><p>The factor (2\u03c0)^{-d} comes from the quantum normalization of \ncoherent states / Weyl quantization.</p></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">volume_element</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">numerical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">x_bounds</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">xi_bounds</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.symplectic_flow", "modulename": "src", "qualname": "PseudoDifferentialOperator.symplectic_flow", "kind": "function", "doc": "<p>Compute the Hamiltonian vector field associated with the principal symbol.</p>\n\n<p>This method derives the canonical equations of motion for the phase space variables \n(x, \u03be) in 1D or (x, y, \u03be, \u03b7) in 2D, based on the Hamiltonian formalism. These describe \nhow position and frequency variables evolve under the flow generated by the symbol.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    A dictionary containing the components of the Hamiltonian vector field:\n    - In 1D: keys are 'dx/dt' and 'dxi/dt', corresponding to dx/dt = \u2202p/\u2202\u03be and d\u03be/dt = -\u2202p/\u2202x.\n    - In 2D: keys are 'dx/dt', 'dy/dt', 'dxi/dt', and 'deta/dt', with similar definitions:\n      dx/dt = \u2202p/\u2202\u03be, dy/dt = \u2202p/\u2202\u03b7, d\u03be/dt = -\u2202p/\u2202x, d\u03b7/dt = -\u2202p/\u2202y.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The Hamiltonian here is the principal symbol p(x, \u03be) itself.</li>\n<li>This flow preserves the symplectic structure of phase space.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.is_elliptic_numerically", "modulename": "src", "qualname": "PseudoDifferentialOperator.is_elliptic_numerically", "kind": "function", "doc": "<p>Check if the pseudo-differential symbol p(x, \u03be) is elliptic over a given grid.</p>\n\n<p>A symbol is considered elliptic if its magnitude |p(x, \u03be)| remains bounded away from zero \nacross all points in the spatial-frequency domain. This method evaluates the symbol on a \ngrid of spatial and frequency coordinates and checks whether its minimum absolute value \nexceeds a specified threshold.</p>\n\n<p>Resampling is applied to large grids to prevent excessive memory usage, particularly in 2D.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x_grid : ndarray\n    Spatial grid: either a 1D array (x) or a tuple of two 1D arrays (x, y).\nxi_grid : ndarray\n    Frequency grid: either a 1D array (\u03be) or a tuple of two 1D arrays (\u03be, \u03b7).\nthreshold : float, optional\n    Minimum acceptable value for |p(x, \u03be)|. If the smallest evaluated symbol value falls below this,\n    the symbol is not considered elliptic.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>bool\n    True if the symbol is elliptic on the resampled grid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x_grid</span>, </span><span class=\"param\"><span class=\"n\">xi_grid</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">1e-08</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.is_self_adjoint", "modulename": "src", "qualname": "PseudoDifferentialOperator.is_self_adjoint", "kind": "function", "doc": "<p>Check whether the pseudo-differential operator is formally self-adjoint (Hermitian).</p>\n\n<p>A self-adjoint operator satisfies P = P<em>, where P</em> is the formal adjoint of P.\nThis property is essential for ensuring real-valued eigenvalues and stable evolution \nin quantum mechanics and symmetric wave propagation.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>tol : float\n    Tolerance for symbolic comparison between P and P*. Small numerical differences \n    below this threshold are considered equal.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>bool\n    True if the symbol p(x, \u03be) equals its formal adjoint p*(x, \u03be) within the given tolerance,\n    indicating that the operator is self-adjoint.</p>\n\n<p>Notes:</p>\n\n<ul>\n<li>The formal adjoint is computed via conjugation and asymptotic expansion at infinity in \u03be.</li>\n<li>Symbolic simplification is used to verify equality, ensuring robustness against superficial \nexpression differences.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-10</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.visualize_fiber", "modulename": "src", "qualname": "PseudoDifferentialOperator.visualize_fiber", "kind": "function", "doc": "<p>Plot the cotangent fiber structure at a fixed spatial point (x\u2080[, y\u2080]).</p>\n\n<p>This visualization shows how the symbol p(x, \u03be) behaves on the cotangent fiber \nabove a fixed spatial point. In microlocal analysis, this provides insight into \nthe frequency content of the operator at that location.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x_grid : ndarray\n    Spatial grid values (1D) for evaluation in 1D case.\nxi_grid : ndarray\n    Frequency grid values (1D) for evaluation in both 1D and 2D cases.\nx0 : float, optional\n    Fixed x-coordinate of the base point in space (1D or 2D).\ny0 : float, optional\n    Fixed y-coordinate of the base point in space (2D only).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>In 1D: Displays |p(x, \u03be)| over the (x, \u03be) phase plane near the fixed point.</li>\n<li>In 2D: Fixes (x\u2080, y\u2080) and evaluates p(x\u2080, y\u2080, \u03be, \u03b7), showing the fiber over that point.</li>\n<li>The color map represents the magnitude of the symbol, highlighting regions where it vanishes or becomes singular.</li>\n</ul>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>NotImplementedError\n    If called in 2D with missing or improperly formatted grids.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x_grid</span>, </span><span class=\"param\"><span class=\"n\">xi_grid</span>, </span><span class=\"param\"><span class=\"n\">x0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">y0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.visualize_symbol_amplitude", "modulename": "src", "qualname": "PseudoDifferentialOperator.visualize_symbol_amplitude", "kind": "function", "doc": "<p>Display the modulus |p(x, \u03be)| or |p(x, y, \u03be\u2080, \u03b7\u2080)| as a color map.</p>\n\n<p>This method visualizes the amplitude of the pseudodifferential operator's symbol \nin either 1D or 2D spatial configuration. In 2D, the frequency variables are fixed \nto specified values (\u03be\u2080, \u03b7\u2080) for visualization purposes.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x_grid, y_grid : ndarray\n    Spatial grids over which to evaluate the symbol. y_grid is optional and used only in 2D.\nxi_grid, eta_grid : ndarray\n    Frequency grids. In 2D, these define the domain over which the symbol is evaluated,\n    but the visualization fixes \u03be = \u03be\u2080 and \u03b7 = \u03b7\u2080.\nxi0, eta0 : float, optional\n    Fixed frequency values for slicing in 2D visualization. Defaults to zero.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>In 1D: Visualizes |p(x, \u03be)| over the (x, \u03be) grid.</li>\n<li>In 2D: Visualizes |p(x, y, \u03be\u2080, \u03b7\u2080)| at fixed frequencies \u03be\u2080 and \u03b7\u2080.</li>\n<li>The color intensity represents the magnitude of the symbol, highlighting regions where the symbol is large or small.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x_grid</span>, </span><span class=\"param\"><span class=\"n\">xi_grid</span>, </span><span class=\"param\"><span class=\"n\">y_grid</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">eta_grid</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">xi0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">eta0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.visualize_phase", "modulename": "src", "qualname": "PseudoDifferentialOperator.visualize_phase", "kind": "function", "doc": "<p>Plot the phase (argument) of the pseudodifferential operator's symbol p(x, \u03be) or p(x, y, \u03be, \u03b7).</p>\n\n<p>This visualization helps in understanding the oscillatory behavior and regularity \nproperties of the operator in phase space. The phase is displayed modulo 2\u03c0 using \na cyclic colormap ('twilight') to emphasize its periodic nature.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x_grid : ndarray\n    1D array of spatial coordinates (x).\nxi_grid : ndarray\n    1D array of frequency coordinates (\u03be).\ny_grid : ndarray, optional\n    2D spatial grid for y-coordinate (in 2D problems). Default is None.\neta_grid : ndarray, optional\n    2D frequency grid for \u03b7 (in 2D problems). Not used directly but kept for API consistency.\nxi0 : float, optional\n    Fixed value of \u03be for slicing in 2D visualization. Default is 0.0.\neta0 : float, optional\n    Fixed value of \u03b7 for slicing in 2D visualization. Default is 0.0.</p>\n\n<p>Notes:</p>\n\n<ul>\n<li>In 1D: Displays arg(p(x, \u03be)) over the (x, \u03be) phase plane.</li>\n<li>In 2D: Displays arg(p(x, y, \u03be\u2080, \u03b7\u2080)) for fixed frequency values (\u03be\u2080, \u03b7\u2080).</li>\n<li>Uses plt.pcolormesh with 'twilight' colormap to represent angles from -\u03c0 to \u03c0.</li>\n</ul>\n\n<p>Raises:</p>\n\n<ul>\n<li>NotImplementedError: If the spatial dimension is not 1D or 2D.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x_grid</span>, </span><span class=\"param\"><span class=\"n\">xi_grid</span>, </span><span class=\"param\"><span class=\"n\">y_grid</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">eta_grid</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">xi0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">eta0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.visualize_characteristic_set", "modulename": "src", "qualname": "PseudoDifferentialOperator.visualize_characteristic_set", "kind": "function", "doc": "<p>Visualize the characteristic set of the pseudo-differential symbol, defined as the approximate zero set p(x, \u03be) \u2248 0.</p>\n\n<p>In microlocal analysis, the characteristic set is the locus of points in phase space (x, \u03be) where the symbol p(x, \u03be) vanishes,\nplaying a key role in understanding propagation of singularities.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x_grid : ndarray\n    Spatial grid values (1D array) for plotting in 1D or evaluation point in 2D.\nxi_grid : ndarray\n    Frequency variable grid values (1D array) used to construct the frequency domain.\nx0 : float, optional\n    Fixed spatial coordinate in 2D case for evaluating the symbol at a specific x position.\ny0 : float, optional\n    Fixed spatial coordinate in 2D case for evaluating the symbol at a specific y position.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>For 1D, this method plots the contour of |p(x, \u03be)| = \u03b5 with \u03b5 = 1e-5 over the (x, \u03be) plane.</li>\n<li>For 2D, it evaluates the symbol at fixed (x\u2080, y\u2080) and plots the characteristic set in the (\u03be, \u03b7) frequency plane.</li>\n<li>This visualization helps identify directions of degeneracy or hypoellipticity of the operator.</li>\n</ul>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>NotImplementedError\n    If called on a solver with dimensionality other than 1D or 2D.</p>\n\n<h2 id=\"displays\">Displays</h2>\n\n<p>A matplotlib contour plot showing either:\n    - The characteristic curve in the (x, \u03be) phase plane (1D),\n    - The characteristic surface slice in the (\u03be, \u03b7) frequency plane at (x\u2080, y\u2080) (2D).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">x_grid</span>,</span><span class=\"param\">\t<span class=\"n\">xi_grid</span>,</span><span class=\"param\">\t<span class=\"n\">y_grid</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">eta_grid</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">y0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">x0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">levels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">0.1</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.visualize_characteristic_gradient", "modulename": "src", "qualname": "PseudoDifferentialOperator.visualize_characteristic_gradient", "kind": "function", "doc": "<p>Visualize the norm of the gradient of the symbol in phase space.</p>\n\n<p>This method computes the magnitude of the gradient |\u2207p| of a pseudo-differential \nsymbol p(x, \u03be) in 1D or p(x, y, \u03be, \u03b7) in 2D. The resulting colormap reveals \nregions where the symbol varies rapidly or remains nearly stationary, \nwhich is particularly useful for analyzing characteristic sets.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x_grid : numpy.ndarray\n    1D array of spatial coordinates for the x-direction.\nxi_grid : numpy.ndarray\n    1D array of frequency coordinates (\u03be).\ny_grid : numpy.ndarray, optional\n    1D array of spatial coordinates for the y-direction (used in 2D mode). Default is None.\neta_grid : numpy.ndarray, optional\n    1D array of frequency coordinates (\u03b7) for the 2D case. Default is None.\nx0 : float, optional\n    Fixed x-coordinate for evaluating the symbol in 2D. Default is 0.0.\ny0 : float, optional\n    Fixed y-coordinate for evaluating the symbol in 2D. Default is 0.0.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None\n    Displays a 2D colormap of |\u2207p| over the relevant phase-space domain.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>In 1D, the full gradient \u2207p = (\u2202\u2093p, \u2202\u03bep) is computed over the (x, \u03be) grid.</li>\n<li>In 2D, the gradient \u2207p = (\u2202\u03bep, \u2202\u03b7p) is computed at a fixed spatial point (x\u2080, y\u2080) over the (\u03be, \u03b7) grid.</li>\n<li>Numerical differentiation is performed using <code>np.gradient</code>.</li>\n<li>High values of |\u2207p| indicate rapid variation of the symbol, while low values typically suggest characteristic regions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x_grid</span>, </span><span class=\"param\"><span class=\"n\">xi_grid</span>, </span><span class=\"param\"><span class=\"n\">y_grid</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">eta_grid</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">y0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">x0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.plot_hamiltonian_flow", "modulename": "src", "qualname": "PseudoDifferentialOperator.plot_hamiltonian_flow", "kind": "function", "doc": "<p>Integrate and plot the Hamiltonian trajectories of the symbol in phase space.</p>\n\n<p>This method numerically integrates the Hamiltonian vector field derived from \nthe operator's symbol to visualize how singularities propagate under the flow. \nIt supports both 1D and 2D problems.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x0, xi0 : float\n    Initial position and frequency (momentum) in 1D.\ny0, eta0 : float, optional\n    Initial position and frequency in 2D; defaults to zero.\ntmax : float\n    Final integration time for the ODE solver.\nn_steps : int\n    Number of time steps used in the integration.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The Hamiltonian vector field is obtained from the symplectic flow of the symbol.</li>\n<li>If the field is complex-valued, only its real part is used for integration.</li>\n<li>In 1D, the trajectory is plotted in (x, \u03be) phase space.</li>\n<li>In 2D, the spatial trajectory (x(t), y(t)) is shown along with instantaneous \nmomentum vectors (\u03be(t), \u03b7(t)) using a quiver plot.</li>\n</ul>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>NotImplementedError\n    If the spatial dimension is not 1D or 2D.</p>\n\n<h2 id=\"displays\">Displays</h2>\n\n<p>matplotlib plot\n    Phase space trajectory(ies) showing the evolution of position and momentum \n    under the Hamiltonian dynamics.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">x0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">xi0</span><span class=\"o\">=</span><span class=\"mf\">5.0</span>,</span><span class=\"param\">\t<span class=\"n\">y0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">eta0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">tmax</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">n_steps</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">show_field</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.plot_symplectic_vector_field", "modulename": "src", "qualname": "PseudoDifferentialOperator.plot_symplectic_vector_field", "kind": "function", "doc": "<p>Visualize the symplectic vector field (Hamiltonian vector field) associated with the operator's symbol.</p>\n\n<p>The plotted vector field corresponds to (\u2202_\u03be p, -\u2202_x p), where p(x, \u03be) is the principal symbol \nof the pseudo-differential operator. This field governs the bicharacteristic flow in phase space.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>xlim : tuple of float\n    Range for spatial variable x, as (x_min, x_max).\nklim : tuple of float\n    Range for frequency variable \u03be, as (\u03be_min, \u03be_max).\ndensity : int\n    Number of grid points per axis for the visualization grid.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>NotImplementedError\n    If called on a 2D operator (currently only 1D implementation available).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Only supports one-dimensional operators.</li>\n<li>Uses symbolic differentiation to compute \u2202_\u03be p and \u2202_x p.</li>\n<li>Numerical evaluation is done via lambdify with NumPy backend.</li>\n<li>Visualization uses matplotlib quiver plot to show vector directions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xlim</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"n\">klim</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"n\">density</span><span class=\"o\">=</span><span class=\"mi\">30</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.visualize_micro_support", "modulename": "src", "qualname": "PseudoDifferentialOperator.visualize_micro_support", "kind": "function", "doc": "<p>Visualize the micro-support of the operator by plotting the inverse of the symbol magnitude 1 / |p(x, \u03be)|.</p>\n\n<p>The micro-support provides insight into the singularities of a pseudo-differential operator \nin phase space (x, \u03be). Regions where |p(x, \u03be)| is small correspond to large values in 1/|p(x, \u03be)|,\nhighlighting areas of significant operator influence or singularity.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>xlim : tuple\n    Spatial domain limits (x_min, x_max).\nklim : tuple\n    Frequency domain limits (\u03be_min, \u03be_max).\nthreshold : float\n    Threshold below which |p(x, \u03be)| is considered effectively zero; used for numerical stability.\ndensity : int\n    Number of grid points along each axis for visualization resolution.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>NotImplementedError\n    If called on a solver with dimension greater than 1 (only 1D visualization is supported).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>This method evaluates the symbol p(x, \u03be) over a grid and plots its reciprocal to emphasize \nregions where the symbol is near zero.</li>\n<li>A small constant (1e-10) is added to the denominator to avoid division by zero.</li>\n<li>The resulting plot helps identify characteristic sets.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xlim</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"n\">klim</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.001</span>, </span><span class=\"param\"><span class=\"n\">density</span><span class=\"o\">=</span><span class=\"mi\">300</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.group_velocity_field", "modulename": "src", "qualname": "PseudoDifferentialOperator.group_velocity_field", "kind": "function", "doc": "<p>Plot the group velocity field \u2207_\u03be p(x, \u03be) for 1D pseudo-differential operators.</p>\n\n<p>The group velocity represents the speed at which waves of different frequencies propagate \nin a dispersive medium. It is defined as the gradient of the symbol p(x, \u03be) with respect \nto the frequency variable \u03be.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>xlim : tuple of float\n    Spatial domain limits (x-axis).\nklim : tuple of float\n    Frequency domain limits (\u03be-axis).\ndensity : int\n    Number of grid points per axis used for visualization.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>NotImplementedError\n    If called on a 2D operator, since this visualization is only implemented for 1D.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>This method visualizes the vector field (\u2202p/\u2202\u03be) in phase space.</li>\n<li>Used for analyzing wave propagation properties and dispersion relations.</li>\n<li>Requires symbolic expression self.expr depending on x and \u03be.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">xlim</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"n\">klim</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>, </span><span class=\"param\"><span class=\"n\">density</span><span class=\"o\">=</span><span class=\"mi\">30</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.animate_singularity", "modulename": "src", "qualname": "PseudoDifferentialOperator.animate_singularity", "kind": "function", "doc": "<p>Animate the propagation of a singularity under the Hamiltonian flow.</p>\n\n<p>This method visualizes how a singularity (x\u2080, y\u2080, \u03be\u2080, \u03b7\u2080) evolves in phase space \naccording to the Hamiltonian dynamics induced by the principal symbol of the operator.\nThe animation integrates the Hamiltonian equations of motion and supports various projections:\nposition (x-y), frequency (\u03be-\u03b7), or mixed phase space coordinates.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>xi0, eta0 : float\n    Initial frequency components (\u03be\u2080, \u03b7\u2080).\nx0, y0 : float\n    Initial spatial coordinates (x\u2080, y\u2080).\ntmax : float\n    Total time of integration (final animation time).\nn_frames : int\n    Number of frames in the resulting animation.\nprojection : str or None\n    Type of projection to display:\n        - 'position' : x vs y (or x alone in 1D)\n        - 'frequency': \u03be vs \u03b7 (or \u03be alone in 1D)\n        - 'phase'    : mixed coordinates like x vs \u03be or x vs \u03b7\n        If None, defaults to 'phase' in 1D and 'position' in 2D.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>matplotlib.animation.FuncAnimation\n    Animation object that can be displayed interactively in Jupyter notebooks or saved as a video.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>In 1D, only one spatial and one frequency variable are used.</li>\n<li>Complex-valued Hamiltonian fields are truncated to their real parts for integration.</li>\n<li>Trajectories are shown with both instantaneous position (dot) and full path (dashed line).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">xi0</span><span class=\"o\">=</span><span class=\"mf\">5.0</span>,</span><span class=\"param\">\t<span class=\"n\">eta0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">x0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">y0</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">tmax</span><span class=\"o\">=</span><span class=\"mf\">4.0</span>,</span><span class=\"param\">\t<span class=\"n\">n_frames</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PseudoDifferentialOperator.interactive_symbol_analysis", "modulename": "src", "qualname": "PseudoDifferentialOperator.interactive_symbol_analysis", "kind": "function", "doc": "<p>Launch an interactive dashboard for symbol exploration using ipywidgets.</p>\n\n<p>This function provides a user-friendly interface to visualize various aspects of the pseudo-differential operator's symbol.\nIt supports multiple visualization modes in both 1D and 2D, including group velocity fields, micro-support estimates,\nsymplectic vector fields, symbol amplitude/phase, cotangent fiber structure, characteristic sets and Hamiltonian flows.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>pseudo_op : PseudoDifferentialOperator\n    The pseudo-differential operator whose symbol is to be analyzed interactively.\nxlim, ylim : tuple of float\n    Spatial domain limits along x and y axes respectively.\nxi_range, eta_range : tuple\n    Frequency domain limits along \u03be and \u03b7 axes respectively.\ndensity : int\n    Number of points per axis used to construct the evaluation grid. Controls resolution.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>In 1D mode, sliders control the fixed frequency (\u03be\u2080) and spatial position (x\u2080).</li>\n<li>In 2D mode, additional sliders control the second frequency component (\u03b7\u2080) and second spatial coordinate (y\u2080).</li>\n<li>Visualization updates dynamically as parameters are adjusted via sliders or dropdown menus.</li>\n<li>Supported visualization modes:\n'Symbol Amplitude'           : |p(x,\u03be)| or |p(x,y,\u03be,\u03b7)|\n'Symbol Phase'               : arg(p(x,\u03be)) or similar in 2D\n'Micro-Support (1/|p|)'      : Reciprocal of symbol magnitude\n'Cotangent Fiber'            : Structure of symbol over frequency space at fixed x\n'Characteristic Set'         : Zero set approximation {p \u2248 0}\n'Characteristic Gradient'    : |\u2207p(x, \u03be)| or |\u2207p(x\u2080, y\u2080, \u03be, \u03b7)|\n'Group Velocity Field'       : \u2207_\u03be p(x,\u03be) or \u2207_{\u03be,\u03b7} p(x,y,\u03be,\u03b7)\n'Symplectic Vector Field'    : (\u2207_\u03be p, -\u2207_x p) or similar in 2D\n'Hamiltonian Flow'           : Trajectories generated by the Hamiltonian vector field</li>\n</ul>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>NotImplementedError\n    If the spatial dimension is not 1D or 2D.</p>\n\n<h2 id=\"prints\">Prints</h2>\n\n<p>Interactive matplotlib figures with dynamic updates based on widget inputs.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pseudo_op</span>,</span><span class=\"param\">\t<span class=\"n\">xlim</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">ylim</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">xi_range</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">eta_range</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">density</span><span class=\"o\">=</span><span class=\"mi\">100</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver", "modulename": "src", "qualname": "PDESolver", "kind": "class", "doc": "<p>A partial differential equation (PDE) solver based on <strong>spectral methods</strong> using Fourier transforms.</p>\n\n<p>This solver supports symbolic specification of PDEs via SymPy and numerical solution using high-order spectral techniques. \nIt is designed for both <strong>linear and nonlinear time-dependent PDEs</strong>, as well as <strong>stationary pseudo-differential problems</strong>.</p>\n\n<h2 id=\"key-features\">Key Features:</h2>\n\n<ul>\n<li>Symbolic PDE parsing using SymPy expressions</li>\n<li>1D and 2D spatial domains with periodic boundary conditions</li>\n<li>Fourier-based spectral discretization with dealiasing</li>\n<li>Temporal integration schemes:\n<ul>\n<li>Default exponential time stepping</li>\n<li>ETD-RK4 (Exponential Time Differencing Runge-Kutta of 4th order)</li>\n</ul></li>\n<li>Nonlinear terms handled through pseudo-spectral evaluation</li>\n<li>Built-in tools for:\n<ul>\n<li>Visualization of solutions and error surfaces</li>\n<li>Symbol analysis of linear and pseudo-differential operators</li>\n<li>Microlocal analysis (e.g., Hamiltonian flows)</li>\n<li>CFL condition checking and numerical stability diagnostics</li>\n</ul></li>\n</ul>\n\n<h2 id=\"supported-operators\">Supported Operators:</h2>\n\n<ul>\n<li>Linear differential and pseudo-differential operators</li>\n<li>Nonlinear terms up to second order in derivatives</li>\n<li>Symbolic operator composition and adjoints</li>\n<li>Asymptotic inversion of elliptic operators for stationary problems</li>\n</ul>\n\n<h2 id=\"example-usage\">Example Usage:</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">PDESolver</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">u</span> <span class=\"o\">=</span> <span class=\"n\">Function</span><span class=\"p\">(</span><span class=\"s1\">&#39;u&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s1\">&#39;t x&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eq</span> <span class=\"o\">=</span> <span class=\"n\">Eq</span><span class=\"p\">(</span><span class=\"n\">diff</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">),</span> <span class=\"n\">t</span><span class=\"p\">),</span> <span class=\"n\">diff</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">),</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">u</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">initial</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span> <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">solver</span> <span class=\"o\">=</span> <span class=\"n\">PDESolver</span><span class=\"p\">(</span><span class=\"n\">eq</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">solver</span><span class=\"o\">.</span><span class=\"n\">setup</span><span class=\"p\">(</span><span class=\"n\">Lx</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"p\">,</span> <span class=\"n\">Nx</span><span class=\"o\">=</span><span class=\"mi\">128</span><span class=\"p\">,</span> <span class=\"n\">Lt</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">Nt</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"n\">initial_condition</span><span class=\"o\">=</span><span class=\"n\">initial</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">solver</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ani</span> <span class=\"o\">=</span> <span class=\"n\">solver</span><span class=\"o\">.</span><span class=\"n\">animate</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">HTML</span><span class=\"p\">(</span><span class=\"n\">ani</span><span class=\"o\">.</span><span class=\"n\">to_jshtml</span><span class=\"p\">())</span>  <span class=\"c1\"># Display animation in Jupyter notebook</span>\n</code></pre>\n</div>\n"}, {"fullname": "src.PDESolver.__init__", "modulename": "src", "qualname": "PDESolver.__init__", "kind": "function", "doc": "<p>Initialize the PDE solver with a given equation.</p>\n\n<p>This method analyzes the input partial differential equation (PDE), \nidentifies the unknown function and its dependencies, determines whether \nthe problem is stationary or time-dependent, and prepares symbolic and \nnumerical structures for solving in spectral space.</p>\n\n<p>Supported features:</p>\n\n<ul>\n<li>1D and 2D problems</li>\n<li>Time-dependent and stationary equations</li>\n<li>Linear and nonlinear terms</li>\n<li>Pseudo-differential operators via <code>psiOp</code></li>\n<li>Source terms and boundary conditions</li>\n</ul>\n\n<p>The equation is parsed to extract linear, nonlinear, source, and \npseudo-differential components. Symbolic manipulation is used to derive \nthe Fourier representation of linear operators when applicable.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>equation : sympy.Eq \n    The PDE expressed as a SymPy equation.\ntime_scheme : str\n    Temporal integration scheme: \n        - 'default' for exponential \n        - time-stepping or 'ETD-RK4' for fourth-order exponential \n        - time differencing Runge\u2013Kutta.\ndealiasing_ratio : float\n    Fraction of high-frequency modes to zero out \n    during dealiasing (e.g., 2/3 for standard truncation).</p>\n\n<p>Attributes initialized:</p>\n\n<ul>\n<li>self.u: the unknown function (e.g., u(t, x))</li>\n<li>self.dim: spatial dimension (1 or 2)</li>\n<li>self.spatial_vars: list of spatial variables (e.g., <input type=\"checkbox\" class=\"task-list-item-checkbox\" checked disabled> or [x, y])</li>\n<li>self.is_stationary: boolean indicating if the problem is stationary</li>\n<li>self.linear_terms: dictionary mapping derivative orders to coefficients</li>\n<li>self.nonlinear_terms: list of nonlinear expressions</li>\n<li>self.source_terms: list of source functions</li>\n<li>self.pseudo_terms: list of pseudo-differential operator expressions</li>\n<li>self.has_psi: boolean indicating presence of pseudo-differential operators</li>\n<li>self.fft / self.ifft: appropriate FFT routines based on spatial dimension</li>\n<li>self.kx, self.ky: symbolic wavenumber variables for Fourier space</li>\n</ul>\n\n<p>Raises:\n    ValueError: If the equation does not contain exactly one unknown function,\n                if unsupported dimensions are detected, or invalid dependencies.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">equation</span>, </span><span class=\"param\"><span class=\"n\">time_scheme</span><span class=\"o\">=</span><span class=\"s1\">&#39;default&#39;</span>, </span><span class=\"param\"><span class=\"n\">dealiasing_ratio</span><span class=\"o\">=</span><span class=\"mf\">0.6666666666666666</span></span>)</span>"}, {"fullname": "src.PDESolver.time_scheme", "modulename": "src", "qualname": "PDESolver.time_scheme", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.dealiasing_ratio", "modulename": "src", "qualname": "PDESolver.dealiasing_ratio", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.is_stationary", "modulename": "src", "qualname": "PDESolver.is_stationary", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.u", "modulename": "src", "qualname": "PDESolver.u", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.u_eq", "modulename": "src", "qualname": "PDESolver.u_eq", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.dim", "modulename": "src", "qualname": "PDESolver.dim", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.linear_terms", "modulename": "src", "qualname": "PDESolver.linear_terms", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.nonlinear_terms", "modulename": "src", "qualname": "PDESolver.nonlinear_terms", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.symbol_terms", "modulename": "src", "qualname": "PDESolver.symbol_terms", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.source_terms", "modulename": "src", "qualname": "PDESolver.source_terms", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.pseudo_terms", "modulename": "src", "qualname": "PDESolver.pseudo_terms", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.temporal_order", "modulename": "src", "qualname": "PDESolver.temporal_order", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.has_psi", "modulename": "src", "qualname": "PDESolver.has_psi", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.PDESolver.parse_equation", "modulename": "src", "qualname": "PDESolver.parse_equation", "kind": "function", "doc": "<p>Parse the PDE to separate linear and nonlinear terms, symbolic operators (Op), \nsource terms, and pseudo-differential operators (psiOp).</p>\n\n<p>This method rewrites the input equation in standard form (lhs - rhs = 0),\nexpands it, and classifies each term into one of the following categories:</p>\n\n<ul>\n<li>Linear terms involving derivatives or the unknown function u</li>\n<li>Nonlinear terms (products with u, powers of u, etc.)</li>\n<li>Symbolic pseudo-differential operators (Op)</li>\n<li>Source terms (independent of u)</li>\n<li>Pseudo-differential operators (psiOp)</li>\n</ul>\n\n<p>Parameters\n    equation (sympy.Eq): The partial differential equation to be analyzed. \n                         Can be provided as an Eq object or a sympy expression.</p>\n\n<p>Returns:\n    tuple: A 5-tuple containing:</p>\n\n<pre><code>    - linear_terms (dict): Mapping from derivative/function to coefficient.\n    - nonlinear_terms (list): List of terms classified as nonlinear.\n    - symbol_terms (list): List of (coefficient, symbolic operator) pairs.\n    - source_terms (list): List of terms independent of the unknown function.\n    - pseudo_terms (list): List of (coefficient, pseudo-differential symbol) pairs.\n</code></pre>\n\n<p>Notes:\n    - If <code>psiOp</code> is present in the equation, expansion is skipped for safety.\n    - When <code>psiOp</code> is used, only nonlinear terms, source terms, and possibly \n      a time derivative are allowed; other linear terms and symbolic operators \n      (Op) are forbidden.\n    - Classification logic includes:\n        - Detection of nonlinear structures like products or powers of u\n        - Mixed terms involving both u and its derivatives\n        - External symbolic operators (Op) and pseudo-differential operators (psiOp)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">equation</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.compute_linear_operator", "modulename": "src", "qualname": "PDESolver.compute_linear_operator", "kind": "function", "doc": "<p>Compute the symbolic Fourier representation L(k) of the linear operator \nderived from the linear part of the PDE.</p>\n\n<p>This method constructs a dispersion relation by applying each symbolic derivative\nto a plane wave exp(i(k\u00b7x - \u03c9t)) and extracting the resulting expression.\nIt handles arbitrary derivative combinations and includes symbolic and\npseudo-differential terms.</p>\n\n<h2 id=\"steps\">Steps:</h2>\n\n<ol>\n<li>Construct a plane wave \u03c6(x, t) = exp(i(k\u00b7x - \u03c9t)).</li>\n<li>Apply each term from self.linear_terms to \u03c6.</li>\n<li>Normalize by \u03c6 and simplify to obtain L(k).</li>\n<li>Include symbolic terms (e.g., psiOp) if present.</li>\n<li>Detect the temporal order from the dispersion relation.</li>\n<li>Build the numerical function L(k) via lambdify.</li>\n</ol>\n\n<h2 id=\"sets\">Sets:</h2>\n\n<ul>\n<li>self.L_symbolic : sympy.Expr\nSymbolic form of L(k).</li>\n<li>self.L : callable\nNumerical function of L(kx[, ky]).</li>\n<li>self.omega : callable or None\nFrequency root \u03c9(k), if available.</li>\n<li>self.temporal_order : int\nOrder of time derivatives detected.</li>\n<li>self.psi_ops : list of (coeff, PseudoDifferentialOperator)\nPseudo-differential terms present in the equation.</li>\n</ul>\n\n<h2 id=\"raises\">Raises:</h2>\n\n<p>ValueError if the dimension is unsupported or the dispersion relation fails.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.linear_rhs", "modulename": "src", "qualname": "PDESolver.linear_rhs", "kind": "function", "doc": "<p>Apply the linear operator (in Fourier space) to the field u or v.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>u : np.ndarray\n    Input solution array.\nis_v : bool\n    Whether to apply the operator to v instead of u.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    Result of applying the linear operator.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">is_v</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.setup", "modulename": "src", "qualname": "PDESolver.setup", "kind": "function", "doc": "<p>Configure the spatial/temporal grid and initialize the solution field.</p>\n\n<p>This method sets up the computational domain, initializes spatial and temporal grids,\napplies boundary conditions, and prepares symbolic and numerical operators.\nIt also performs essential analyses such as:</p>\n\n<pre><code>- CFL condition verification (for stability)\n- Symbol analysis (e.g., dispersion relation, regularity)\n- Wave propagation analysis for second-order equations\n</code></pre>\n\n<p>If pseudo-differential operators (\u03c8Op) are present, symbolic analysis is skipped\nin favor of interactive exploration via <code>interactive_symbol_analysis</code>.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>Lx : float\n    Size of the spatial domain along x-axis.\nLy : float, optional\n    Size of the spatial domain along y-axis (for 2D problems).\nNx : int\n    Number of spatial points along x-axis.\nNy : int, optional\n    Number of spatial points along y-axis (for 2D problems).\nLt : float, default=1.0\n    Total simulation time.\nNt : int, default=100\n    Number of time steps.\ninitial_condition : callable\n    Function returning the initial state u(x, 0) or u(x, y, 0).\ninitial_velocity : callable, optional\n    Function returning the initial time derivative \u2202\u209cu(x, 0) or \u2202\u209cu(x, y, 0),\n    required for second-order equations.\nn_frames : int, default=100\n    Number of time frames to store during simulation for visualization or output.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If mandatory parameters are missing (e.g., Nx not given in 1D, Ly/Ny not given in 2D).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The spatial discretization assumes periodic boundary conditions by default.</li>\n<li>Fourier transforms are computed using real-to-complex FFTs (<code>scipy.fft.fft</code>, <code>fft2</code>).</li>\n<li>Frequency arrays (<code>KX</code>, <code>KY</code>) are defined following standard spectral conventions.</li>\n<li>Dealiasing is applied using a sharp cutoff filter at a fraction of the maximum frequency.</li>\n<li>For second-order equations, initial acceleration is derived from the governing operator.</li>\n<li>Symbolic analysis includes plotting of the symbol's real/imaginary/absolute values\nand dispersion relation.</li>\n</ul>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>setup_1D : Sets up internal variables for one-dimensional problems.\nsetup_2D : Sets up internal variables for two-dimensional problems.\ninitialize_conditions : Applies initial data and enforces compatibility.\ncheck_cfl_condition : Verifies time step against stability constraints.\nplot_symbol : Visualizes the linear operator\u2019s symbol in frequency space.\nanalyze_wave_propagation : Analyzes group velocity.\ninteractive_symbol_analysis : Interactive tools for \u03c8Op-based equations.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">Lx</span>,</span><span class=\"param\">\t<span class=\"n\">Ly</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">Nx</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">Ny</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">Lt</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">Nt</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">boundary_condition</span><span class=\"o\">=</span><span class=\"s1\">&#39;periodic&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">initial_condition</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">initial_velocity</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_frames</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">plot</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.setup_1D", "modulename": "src", "qualname": "PDESolver.setup_1D", "kind": "function", "doc": "<p>Configure internal variables for one-dimensional (1D) problems.</p>\n\n<p>This private method initializes spatial and frequency grids, applies dealiasing,\nand prepares either pseudo-differential symbols or linear operators for use in time evolution.</p>\n\n<p>It assumes periodic boundary conditions and uses real-to-complex FFT conventions.\nThe spatial domain is centered at zero: [-Lx/2, Lx/2].</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>Lx : float\n    Physical size of the spatial domain along the x-axis.\nNx : int\n    Number of grid points in the x-direction.</p>\n\n<h2 id=\"attributes-set\">Attributes Set</h2>\n\n<ul>\n<li>self.Lx : float\nSize of the spatial domain.</li>\n<li>self.Nx : int\nNumber of spatial points.</li>\n<li>self.x_grid : np.ndarray\n1D array of spatial coordinates.</li>\n<li>self.X : np.ndarray\nAlias to <code>self.x_grid</code>, used in physical space computations.</li>\n<li>self.kx : np.ndarray\nArray of wavenumbers corresponding to the Fourier transform.</li>\n<li>self.KX : np.ndarray\nAlias to <code>self.kx</code>, used in frequency space computations.</li>\n<li>self.dealiasing_mask : np.ndarray\nBoolean mask used to suppress aliased frequencies during nonlinear calculations.</li>\n<li>self.exp_L : np.ndarray\nExponential of the linear operator scaled by time step: exp(L(k) \u00b7 dt).</li>\n<li>self.omega_val : np.ndarray\nFrequency values \u03c9(k) = Re[\u221a(L(k))] used in second-order time stepping.</li>\n<li>self.cos_omega_dt, self.sin_omega_dt : np.ndarray\nCosine and sine of \u03c9(k)\u00b7dt for dispersive propagation.</li>\n<li>self.inv_omega : np.ndarray\nInverse of \u03c9(k), used to avoid division-by-zero in time stepping.</li>\n</ul>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Frequencies are computed using <code>scipy.fft.fftfreq</code> and then shifted to center zero frequency.</li>\n<li>Dealiasing is applied using a sharp cutoff filter based on <code>self.dealiasing_ratio</code>.</li>\n<li>If pseudo-differential operators (\u03c8Op) are present, symbolic tables are precomputed via <code>prepare_symbol_tables</code>.</li>\n<li>For second-order equations, the dispersion relation \u03c9(k) is extracted from the linear operator L(k).</li>\n</ul>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>setup_2D : Equivalent setup for two-dimensional problems.\nprepare_symbol_tables : Precomputes symbolic arrays for \u03c8Op evaluation.\nsetup_omega_terms : Sets up terms involving \u03c9(k) for second-order evolution.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">Lx</span>, </span><span class=\"param\"><span class=\"n\">Nx</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.setup_2D", "modulename": "src", "qualname": "PDESolver.setup_2D", "kind": "function", "doc": "<p>Configure internal variables for two-dimensional (2D) problems.</p>\n\n<p>This private method initializes spatial and frequency grids, applies dealiasing,\nand prepares either pseudo-differential symbols or linear operators for use in time evolution.</p>\n\n<p>It assumes periodic boundary conditions and uses real-to-complex FFT conventions.\nThe spatial domain is centered at zero: [-Lx/2, Lx/2] \u00d7 [-Ly/2, Ly/2].</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>Lx : float\n    Physical size of the spatial domain along the x-axis.\nLy : float\n    Physical size of the spatial domain along the y-axis.\nNx : int\n    Number of grid points along the x-direction.\nNy : int\n    Number of grid points along the y-direction.</p>\n\n<h2 id=\"attributes-set\">Attributes Set</h2>\n\n<ul>\n<li>self.Lx, self.Ly : float\nSize of the spatial domain in each direction.</li>\n<li>self.Nx, self.Ny : int\nNumber of spatial points in each direction.</li>\n<li>self.x_grid, self.y_grid : np.ndarray\n1D arrays of spatial coordinates in x and y directions.</li>\n<li>self.X, self.Y : np.ndarray\n2D meshgrids of spatial coordinates for physical space computations.</li>\n<li>self.kx, self.ky : np.ndarray\nArrays of wavenumbers corresponding to Fourier transforms in x and y directions.</li>\n<li>self.KX, self.KY : np.ndarray\nMeshgrids of wavenumbers used in frequency space computations.</li>\n<li>self.dealiasing_mask : np.ndarray\nBoolean mask used to suppress aliased frequencies during nonlinear calculations.</li>\n<li>self.exp_L : np.ndarray\nExponential of the linear operator scaled by time step: exp(L(kx, ky) \u00b7 dt).</li>\n<li>self.omega_val : np.ndarray\nFrequency values \u03c9(kx, ky) = Re[\u221a(L(kx, ky))] used in second-order time stepping.</li>\n<li>self.cos_omega_dt, self.sin_omega_dt : np.ndarray\nCosine and sine of \u03c9(kx, ky)\u00b7dt for dispersive propagation.</li>\n<li>self.inv_omega : np.ndarray\nInverse of \u03c9(kx, ky), used to avoid division-by-zero in time stepping.</li>\n</ul>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Frequencies are computed using <code>scipy.fft.fftfreq</code> and then shifted to center zero frequency.</li>\n<li>Dealiasing is applied using a sharp cutoff filter based on <code>self.dealiasing_ratio</code>.</li>\n<li>If pseudo-differential operators (\u03c8Op) are present, symbolic tables are precomputed via <code>prepare_symbol_tables</code>.</li>\n<li>For second-order equations, the dispersion relation \u03c9(kx, ky) is extracted from the linear operator L(kx, ky).</li>\n</ul>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>setup_1D : Equivalent setup for one-dimensional problems.\nprepare_symbol_tables : Precomputes symbolic arrays for \u03c8Op evaluation.\nsetup_omega_terms : Sets up terms involving \u03c9(kx, ky) for second-order evolution.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">Lx</span>, </span><span class=\"param\"><span class=\"n\">Ly</span>, </span><span class=\"param\"><span class=\"n\">Nx</span>, </span><span class=\"param\"><span class=\"n\">Ny</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.setup_omega_terms", "modulename": "src", "qualname": "PDESolver.setup_omega_terms", "kind": "function", "doc": "<p>Initialize terms derived from the angular frequency \u03c9 for time evolution.</p>\n\n<p>This private method precomputes and stores key trigonometric and inverse quantities\nbased on the dispersion relation \u03c9(k), used in second-order time integration schemes.</p>\n\n<p>These values are essential for solving wave-like equations with dispersive behavior:\n    cos(\u03c9\u00b7dt), sin(\u03c9\u00b7dt), 1/\u03c9</p>\n\n<p>The inverse frequency is computed safely to avoid division by zero.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>omega_val : np.ndarray\n    Array of angular frequency values \u03c9(k) evaluated at discrete wavenumbers.\n    Can be one-dimensional (1D) or two-dimensional (2D) depending on spatial dimension.</p>\n\n<h2 id=\"attributes-set\">Attributes Set</h2>\n\n<ul>\n<li>self.omega_val : np.ndarray\nCopy of the input angular frequency array.</li>\n<li>self.cos_omega_dt : np.ndarray\nCosine of \u03c9(k) multiplied by time step: cos(\u03c9(k) \u00b7 dt).</li>\n<li>self.sin_omega_dt : np.ndarray\nSine of \u03c9(k) multiplied by time step: sin(\u03c9(k) \u00b7 dt).</li>\n<li>self.inv_omega : np.ndarray\nInverse of \u03c9(k), with zeros where \u03c9(k) == 0 to avoid division by zero.</li>\n</ul>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>This method is typically called during setup when solving second-order PDEs\ninvolving dispersive waves (e.g., Klein-Gordon, Schr\u00f6dinger, or water wave equations).</li>\n<li>The safe computation of 1/\u03c9 ensures numerical stability even when low frequencies are present.</li>\n<li>These precomputed arrays are used in spectral propagators for accurate time stepping.</li>\n</ul>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>setup_1D : Sets up internal variables for one-dimensional problems.\nsetup_2D : Sets up internal variables for two-dimensional problems.\nsolve : Time integration using the computed frequency terms.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">omega_val</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.evaluate_source_at_t0", "modulename": "src", "qualname": "PDESolver.evaluate_source_at_t0", "kind": "function", "doc": "<p>Evaluate source terms at initial time t = 0 over the spatial grid.</p>\n\n<p>This private method computes the total contribution of all source terms at the initial time,\nevaluated across the entire spatial domain. It supports both one-dimensional (1D) and\ntwo-dimensional (2D) configurations.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>np.ndarray\n    A numpy array representing the evaluated source term at t=0:\n    - In 1D: Shape (Nx,), evaluated at each x in <code>self.x_grid</code>.\n    - In 2D: Shape (Nx, Ny), evaluated at each (x, y) pair in the grid.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The symbolic expressions in <code>self.source_terms</code> are substituted with numerical values at t=0.</li>\n<li>In 1D, each term is evaluated at (t=0, x=x_val).</li>\n<li>In 2D, each term is evaluated at (t=0, x=x_val, y=y_val).</li>\n<li>Evaluated using SymPy's <code>evalf()</code> to ensure numeric conversion.</li>\n<li>This method assumes that the source terms have already been lambdified or are compatible with symbolic substitution.</li>\n</ul>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>setup : Initializes the spatial grid and source terms.\nsolve : Uses this evaluation during the first time step.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.initialize_conditions", "modulename": "src", "qualname": "PDESolver.initialize_conditions", "kind": "function", "doc": "<p>Initialize the solution and velocity fields at t = 0.</p>\n\n<p>This private method sets up the initial state of the solution <code>u_prev</code> and, if applicable,\nthe time derivative (velocity) <code>v_prev</code> for second-order evolution equations.</p>\n\n<p>For second-order equations, it also computes the backward-in-time value <code>u_prev2</code>\nneeded by the Leap-Frog method. The acceleration at t = 0 is computed from:\n    \u2202\u209c\u00b2u = L(u) + N(u) + f(x, t=0)\nwhere L is the linear operator, N is the nonlinear term, and f is the source term.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>initial_condition : callable\n    Function returning the initial condition u(x, 0) or u(x, y, 0).\ninitial_velocity : callable or None\n    Function returning the initial velocity \u2202\u209cu(x, 0) or \u2202\u209cu(x, y, 0). Required for\n    second-order equations; ignored otherwise.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>initial_velocity</code> is not provided for second-order equations.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Applies periodic boundary conditions after setting initial data.</li>\n<li>Stores a copy of the initial state in <code>self.frames</code> for visualization/output.</li>\n<li>In second-order systems, initializes <code>self.u_prev2</code> using a Taylor expansion:\nu_prev2 = u_prev - dt * v_prev + 0.5 * dt\u00b2 * (\u2202\u209c\u00b2u)</li>\n</ul>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>apply_boundary : Enforces periodic boundary conditions on the solution field.\npsiOp_apply : Computes pseudo-differential operator action for acceleration.\nlinear_rhs : Evaluates linear part of the equation in Fourier space.\napply_nonlinear : Handles nonlinear terms with spectral differentiation.\nevaluate_source_at_t0 : Evaluates source terms at the initial time.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">initial_condition</span>, </span><span class=\"param\"><span class=\"n\">initial_velocity</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.apply_boundary", "modulename": "src", "qualname": "PDESolver.apply_boundary", "kind": "function", "doc": "<p>Apply boundary conditions to the solution array based on the specified type.</p>\n\n<p>This method supports two types of boundary conditions:</p>\n\n<ul>\n<li>'periodic': Enforces periodicity by copying opposite boundary values.</li>\n<li>'dirichlet': Sets all boundary values to zero (homogeneous Dirichlet condition).</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>u : np.ndarray\n    The solution array representing the field values on a spatial grid.\n    In 1D, shape must be (Nx,). In 2D, shape must be (Nx, Ny).</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If <code>self.boundary_condition</code> is not one of {'periodic', 'dirichlet'}.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>For 'periodic':\n<ul>\n<li>In 1D: u[0] = u[-2], u[-1] = u[1]</li>\n<li>In 2D: First and last rows/columns are set equal to their neighbors.</li>\n</ul></li>\n<li>For 'dirichlet':\n<ul>\n<li>All boundary points are explicitly set to zero.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.apply_nonlinear", "modulename": "src", "qualname": "PDESolver.apply_nonlinear", "kind": "function", "doc": "<p>Apply nonlinear terms to the solution using spectral differentiation with dealiasing.</p>\n\n<p>This method evaluates all nonlinear terms present in the PDE by substituting spatial \nderivatives with their spectral approximations computed via FFT. The dealiasing mask \nensures numerical stability by removing high-frequency components that could lead \nto aliasing errors.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>u : numpy.ndarray\n    Current solution array on the spatial grid.\nis_v : bool\n    If True, evaluates nonlinear terms for the velocity field v instead of u.</p>\n\n<p>Returns:\n    numpy.ndarray: Array representing the contribution of nonlinear terms multiplied by dt.</p>\n\n<p>Notes:</p>\n\n<ul>\n<li>In 1D, computes \u2202\u2093u via FFT and substitutes any derivative term in the nonlinear expressions.</li>\n<li>In 2D, computes \u2202\u2093u and \u2202\u1d67u via FFT and performs similar substitutions.</li>\n<li>Uses lambdify to evaluate symbolic nonlinear expressions numerically.</li>\n<li>Derivatives are replaced symbolically with 'u_x' and 'u_y' before evaluation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">is_v</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.prepare_symbol_tables", "modulename": "src", "qualname": "PDESolver.prepare_symbol_tables", "kind": "function", "doc": "<p>Precompute and store evaluated pseudo-differential operator symbols for spectral methods.</p>\n\n<p>This method evaluates all pseudo-differential operators (\u03c8Op) present in the PDE\nover the spatial and frequency grids, scales them by their respective coefficients,\nand combines them into a single composite symbol used in time-stepping and inversion.</p>\n\n<p>The evaluation is performed via the <code>evaluate</code> method of each PseudoDifferentialOperator,\nwhich computes p(x, \u03be) or p(x, y, \u03be, \u03b7) numerically over the current grid configuration.</p>\n\n<p>Side Effects:\n    self.precomputed_symbols : list of (coeff, symbol_array)\n        Each tuple contains a coefficient and its evaluated symbol on the grid.\n    self.combined_symbol : np.ndarray\n        Sum of all scaled symbol arrays: \u2211(coeff\u2096 * \u03c8\u2096(x, \u03be))</p>\n\n<p>Raises:\n    ValueError: If the spatial dimension is not 1D or 2D.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.total_symbol_expr", "modulename": "src", "qualname": "PDESolver.total_symbol_expr", "kind": "function", "doc": "<p>Compute the total pseudo-differential symbol expression from all pseudo_terms.</p>\n\n<p>This method constructs the full symbol of the pseudo-differential operator\nby summing up all coefficient-weighted symbolic expressions.</p>\n\n<p>The result is cached in self.symbol_expr to avoid recomputation.</p>\n\n<p>Returns:\n    sympy.Expr: The combined symbol expression, representing the full\n                pseudo-differential operator in symbolic form.</p>\n\n<p>Example:\n    Given pseudo_terms = [(2, \u03be\u00b2), (1, x\u00b7\u03be)], this returns 2\u00b7\u03be\u00b2 + x\u00b7\u03be.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.build_symbol_func", "modulename": "src", "qualname": "PDESolver.build_symbol_func", "kind": "function", "doc": "<p>Build a numerical evaluation function from a symbolic pseudo-differential operator expression.</p>\n\n<p>This method converts a symbolic expression representing a pseudo-differential operator into\na callable NumPy-compatible function. The function accepts spatial and frequency variables\ndepending on the dimensionality of the problem.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>expr : sympy expression\n    A SymPy expression representing the symbol of the pseudo-differential operator. It may depend on spatial variables (x, y) and frequency variables (xi, eta).</p>\n\n<p>Returns:\n    function : A lambdified function that takes:</p>\n\n<pre><code>    - In 1D: `(x, xi)` \u2014 spatial coordinate and frequency.\n    - In 2D: `(x, y, xi, eta)` \u2014 spatial coordinates and frequencies.\n\n  Returns a NumPy array of evaluated symbol values over input grids.\n</code></pre>\n\n<p>Notes:\n    - Uses <code>lambdify</code> from SymPy with the <code>'numpy'</code> backend for efficient vectorized evaluation.\n    - Real variable assumptions are enforced to ensure proper behavior in numerical contexts.\n    - Used internally by methods like <code>apply_psiOp</code>, <code>evaluate</code>, and visualization tools.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">expr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.apply_psiOp", "modulename": "src", "qualname": "PDESolver.apply_psiOp", "kind": "function", "doc": "<p>Apply the pseudo-differential operator to the input field u.</p>\n\n<p>This method dispatches the application of the pseudo-differential operator based on:</p>\n\n<ul>\n<li>Whether the symbol is spatially dependent (x/y)</li>\n<li>The boundary condition in use (periodic or dirichlet)</li>\n</ul>\n\n<p>Supported operations:</p>\n\n<ul>\n<li>Constant-coefficient symbols: applied via Fourier multiplication.</li>\n<li>Spatially varying symbols: applied via Kohn\u2013Nirenberg quantization.</li>\n<li>Dirichlet boundary conditions: handled with non-periodic convolution-like quantization.</li>\n</ul>\n\n<p>Dispatch Logic:</p>\n\n<p>if not self.is_spatial: u \u21a6 Op(p)(D) \u22c5 u = \ud835\udcd5\u207b\u00b9[ p(\u03be) \u22c5 \ud835\udcd5(u) ]</p>\n\n<p>elif periodic: u \u21a6 Op(p)(x,D) \u22c5 u \u2248 \u222b e\u1da6\u02e3\u1dbf p(x, \u03be) \ud835\udcd5(u)(\u03be) d\u03be based of FFT (quicker)</p>\n\n<p>elif dirichlet: u \u21a6 Op(p)(x,D) \u22c5 u \u2248 u \u2248 \u222b e\u1da6\u02e3\u1dbf p(x, \u03be) \ud835\udcd5(u)(\u03be) d\u03be (slower)</p>\n\n<p>This method delegates to the apply() method of each \nPseudoDifferentialOperator instance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>u : ndarray\n    Function to which operators are applied</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    Result of applying all operators with their coefficients</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.step_order1_with_psi", "modulename": "src", "qualname": "PDESolver.step_order1_with_psi", "kind": "function", "doc": "<p>Perform one time step of a first-order evolution using a pseudo-differential operator.</p>\n\n<p>This method updates the solution field using an exponential integrator or explicit Euler scheme,\ndepending on boundary conditions and the structure of the pseudo-differential symbol.\nIt supports:</p>\n\n<ul>\n<li>Linear dynamics via pseudo-differential operator L (possibly nonlocal)</li>\n<li>Nonlinear terms computed via spectral differentiation</li>\n<li>External source contributions</li>\n</ul>\n\n<p>The update follows <strong>three distinct computational paths</strong>:</p>\n\n<ol>\n<li><p><strong>Periodic boundaries + diagonalizable symbol</strong><br />\nSymbol is constant in space \u2192 use direct Fourier-based exponential integrator:<br />\n    u\u2099\u208a\u2081 = e\u207b\u1d38\u0394\u1d57 \u22c5 u\u2099 + \u0394t \u22c5 \u03c6\u2081(\u2212L\u0394t) \u22c5 (N(u\u2099) + F)</p></li>\n<li><p><strong>Non-diagonalizable but spatially uniform symbol</strong><br />\nGeneral exponential time differencing of order 1:<br />\n    u\u2099\u208a\u2081 = e\u1d38\u0394\u1d57 \u22c5 u\u2099 + \u0394t \u22c5 \u03c6\u2081(L\u0394t) \u22c5 (N(u\u2099) + F)</p></li>\n<li><p><strong>Spatially varying symbol</strong><br />\nNo frequency diagonalization available \u2192 use explicit Euler:<br />\n    u\u2099\u208a\u2081 = u\u2099 + \u0394t \u22c5 (L(u\u2099) + N(u\u2099) + F)</p></li>\n</ol>\n\n<p>where:\n    L(u\u2099) = linear part via pseudo-differential operator\n    N(u\u2099) = nonlinear contribution at current time step\n    F     = external source term\n    \u0394t    = time step size\n    \u03c6\u2081(z) = (e\u1dbb \u2212 1)/z (with safe handling near z=0)</p>\n\n<p>Boundary conditions are applied after each update to ensure consistency.</p>\n\n<p>Parameters\n    source_contribution (np.ndarray): Array representing the external source term at current time step.\n                                      Must match the spatial dimensions of self.u_prev.</p>\n\n<p>Returns:\n    np.ndarray: Updated solution array after one time step.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">source_contribution</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.step_order2_with_psi", "modulename": "src", "qualname": "PDESolver.step_order2_with_psi", "kind": "function", "doc": "<p>Perform one time step of a second-order time evolution using a pseudo-differential operator.</p>\n\n<p>This method updates the solution field using a second-order accurate scheme suitable for wave-like equations.\nThe update includes contributions from:</p>\n\n<ul>\n<li>Linear dynamics via a pseudo-differential operator (e.g., dispersion or stiffness)</li>\n<li>Nonlinear terms computed via spectral differentiation</li>\n<li>External source contributions</li>\n</ul>\n\n<p>Discretization follows a leapfrog-style finite difference in time:</p>\n\n<pre><code>u\u2099\u208a\u2081 = 2u\u2099 \u2212 u\u2099\u208b\u2081 + \u0394t\u00b2 \u22c5 (L(u\u2099) + N(u\u2099) + F)\n</code></pre>\n\n<p>where:\n    L(u\u2099) = linear part evaluated via pseudo-differential operator\n    N(u\u2099) = nonlinear contribution at current time step\n    F     = external source term at current time step\n    \u0394t    = time step size</p>\n\n<p>Boundary conditions are applied after each update to ensure consistency.</p>\n\n<p>Parameters\n    source_contribution (np.ndarray): Array representing the external source term at current time step.\n                                      Must match the spatial dimensions of self.u_prev.</p>\n\n<p>Returns:\n    np.ndarray: Updated solution array after one time step.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">source_contribution</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.solve", "modulename": "src", "qualname": "PDESolver.solve", "kind": "function", "doc": "<p>Solve the partial differential equation numerically using spectral methods.</p>\n\n<p>This method evolves the solution in time using a combination of:</p>\n\n<ul>\n<li>Fourier-based linear evolution (with dealiasing)</li>\n<li>Nonlinear term handling via pseudo-spectral evaluation</li>\n<li>Support for pseudo-differential operators (psiOp)</li>\n<li>Source terms and boundary conditions</li>\n</ul>\n\n<p>The solver supports:</p>\n\n<ul>\n<li>1D and 2D spatial domains</li>\n<li>First and second-order time evolution</li>\n<li>Periodic and Dirichlet boundary conditions</li>\n<li>Time-stepping schemes: default, ETD-RK4</li>\n</ul>\n\n<p>Returns:\n    list[np.ndarray]: A list of solution arrays at each saved time frame.</p>\n\n<p>Side Effects:\n    - Updates self.frames: stores solution snapshots\n    - Updates self.energy_history: records total energy if enabled</p>\n\n<p>Algorithm Overview:\n    For each time step:\n        1. Evaluate source contributions (if any)\n        2. Apply time evolution:\n            - Order 1:\n                - With psiOp: uses step_order1_with_psi\n                - With ETD-RK4: exponential time differencing\n                - Default: linear + nonlinear update\n            - Order 2:\n                - With psiOp: uses step_order2_with_psi\n                - With ETD-RK4: second-order exponential scheme\n                - Default: second-order leapfrog-style update\n        3. Enforce boundary conditions\n        4. Save solution snapshot periodically\n        5. Record energy (for second-order systems without psiOp)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.solve_stationary_psiOp", "modulename": "src", "qualname": "PDESolver.solve_stationary_psiOp", "kind": "function", "doc": "<p>Solve stationary pseudo-differential equations of the form P[u] = f(x) or P[u] = f(x,y) using asymptotic inversion.</p>\n\n<p>This method computes the solution to a stationary (time-independent) pseudo-differential equation\nwhere the operator P is defined via symbolic expressions (psiOp). It constructs an asymptotic right inverse R \nsuch that P\u2218R \u2248 Id, then applies it to the source term f using either direct Fourier multiplication \n(when the symbol is spatially independent) or Kohn\u2013Nirenberg quantization (when spatial dependence is present).</p>\n\n<p>The inversion is based on the principal symbol of the operator and its asymptotic expansion up to the given order.\nEllipticity of the symbol is checked numerically before inversion to ensure well-posedness.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>order : int, default=3\n    Order of the asymptotic expansion used to construct the right inverse of the pseudo-differential operator.\nmethod : str, optional\n    Inversion strategy:\n    - 'diagonal' (default): Fast approximate inversion using diagonal operators in frequency space.\n    - 'full'                : Pointwise exact inversion (slower but more accurate).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    The computed solution u(x) in 1D or u(x, y) in 2D as a NumPy array over the spatial grid.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If no pseudo-differential operator (psiOp) is defined.\n    If linear or nonlinear terms other than psiOp are present.\n    If the symbol is not elliptic on the grid.\n    If no source term is provided for the right-hand side.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The method assumes the problem is fully stationary: time derivatives must be absent.</li>\n<li>Requires the equation to be purely pseudo-differential (no Op, Derivative, or nonlinear terms).</li>\n<li>Symbol evaluation and inversion are dimension-aware (supports both 1D and 2D problems).</li>\n<li>Supports optimization paths when the symbol does not depend on spatial variables.</li>\n</ul>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>right_inverse_asymptotic : Constructs the asymptotic inverse of the pseudo-differential operator.\nkohn_nirenberg           : Numerical implementation of general pseudo-differential operators.\nis_elliptic_numerically  : Verifies numerical ellipticity of the symbol.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.step_ETD_RK4", "modulename": "src", "qualname": "PDESolver.step_ETD_RK4", "kind": "function", "doc": "<p>Perform one Exponential Time Differencing Runge-Kutta of 4th order (ETD-RK4) time step \nfor first-order in time PDEs of the form:</p>\n\n<pre><code>\u2202\u209cu = L u + N(u)\n</code></pre>\n\n<p>where L is a linear operator (possibly nonlocal or pseudo-differential), and N is a \nnonlinear term treated via pseudo-spectral methods. This method evaluates the \nexponential integrator up to fourth-order accuracy in time.</p>\n\n<p>The ETD-RK4 scheme uses four stages to approximate the integral of the variation-of-constants formula:</p>\n\n<pre><code>u\u207f\u207a\u00b9 = e^(L \u0394t) u\u207f + \u0394t \u222b\u2080\u00b9 e^(L \u0394t (1 - \u03c4)) \u03c6(N(u(\u03c4))) d\u03c4\n</code></pre>\n\n<p>where \u03c6 denotes the nonlinear contributions evaluated at intermediate stages.</p>\n\n<p>Parameters\n    u (np.ndarray): Current solution in real space (physical grid values).</p>\n\n<p>Returns:\n    np.ndarray: Updated solution in real space after one ETD-RK4 time step.</p>\n\n<p>Notes:</p>\n\n<ul>\n<li>The linear part L is diagonal in Fourier space and precomputed as self.L(k).</li>\n<li>Nonlinear terms are evaluated in physical space and transformed via FFT.</li>\n<li>The functions \u03c6\u2081(z) and \u03c6\u2082(z) are entire functions arising from the ETD scheme:</li>\n</ul>\n\n<pre><code>  \u03c6\u2081(z) = (e\u1dbb - 1)/z   if z \u2260 0\n         = 1            if z = 0\n\n  \u03c6\u2082(z) = (e\u1dbb - 1 - z)/z\u00b2   if z \u2260 0\n         = \u00bd              if z = 0\n</code></pre>\n\n<ul>\n<li>This implementation assumes periodic boundary conditions and uses spectral differentiation via FFT.</li>\n<li>See Hochbruck &amp; Ostermann (2010) for theoretical background on exponential integrators.</li>\n</ul>\n\n<p>See Also:\n    step_ETD_RK4_order2 : For second-order in time equations.\n    psiOp_apply           : For applying pseudo-differential operators.\n    apply_nonlinear      : For handling nonlinear terms in the PDE.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.step_ETD_RK4_order2", "modulename": "src", "qualname": "PDESolver.step_ETD_RK4_order2", "kind": "function", "doc": "<p>Perform one time step of the Exponential Time Differencing Runge-Kutta 4th-order (ETD-RK4) scheme for second-order PDEs.</p>\n\n<p>This method evolves the solution u and its time derivative v forward in time by one step using the ETD-RK4 integrator. \nIt is designed for systems of the form:</p>\n\n<pre><code>\u2202\u209c\u00b2u = L u + N(u)\n</code></pre>\n\n<p>where L is a linear operator and N is a nonlinear term computed via self.apply_nonlinear.</p>\n\n<p>The exponential integrator handles the linear part exactly in Fourier space, while the nonlinear terms are integrated \nusing a fourth-order Runge-Kutta-like approach. This ensures high accuracy and stability for stiff systems.</p>\n\n<p>Parameters:\n    u (np.ndarray): Current solution array in real space.\n    v (np.ndarray): Current time derivative of the solution (\u2202\u209cu) in real space.</p>\n\n<p>Returns:\n    tuple: (u_new, v_new), updated solution and its time derivative after one time step.</p>\n\n<p>Notes:\n    - Assumes periodic boundary conditions and uses FFT-based spectral methods.\n    - Handles both 1D and 2D problems seamlessly.\n    - Uses phi functions to compute exponential integrators efficiently.\n    - Suitable for wave equations and other second-order evolution equations with stiffness.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.check_cfl_condition", "modulename": "src", "qualname": "PDESolver.check_cfl_condition", "kind": "function", "doc": "<p>Check the CFL (Courant\u2013Friedrichs\u2013Lewymann) condition based on group velocity \nfor second-order time-dependent PDEs.</p>\n\n<p>This method verifies whether the chosen time step dt satisfies the numerical stability \ncondition derived from the maximum wave propagation speed in the system. It supports both \n1D and 2D problems, with or without a symbolic dispersion relation \u03c9(k).</p>\n\n<p>The CFL condition ensures that information does not propagate further than one grid cell \nper time step. A safety factor of 0.5 is applied by default to ensure robustness.</p>\n\n<p>Notes:</p>\n\n<ul>\n<li>In 1D, the group velocity v\u2089(k) = d\u03c9/dk is used to compute the maximum wave speed.</li>\n<li>In 2D, the x- and y-directional group velocities are evaluated independently.</li>\n<li>If no dispersion relation is available, the imaginary part of the linear operator L(k) \nis used as an approximation for wave speed.</li>\n</ul>\n\n<h2 id=\"raises\">Raises:</h2>\n\n<p>NotImplementedError: \n    If the spatial dimension is not 1D or 2D.</p>\n\n<h2 id=\"prints\">Prints:</h2>\n\n<p>Warning message if the current time step dt exceeds the CFL-stable limit.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.check_symbol_conditions", "modulename": "src", "qualname": "PDESolver.check_symbol_conditions", "kind": "function", "doc": "<p>Check strict analytic conditions on the linear symbol self.L_symbolic:\n    This method evaluates three key properties of the Fourier multiplier \n    symbol a(k) = self.L(k), which are crucial for well-posedness, stability,\n    and numerical efficiency. The checks apply to both 1D and 2D cases.</p>\n\n<h2 id=\"conditions-checked\">Conditions checked:</h2>\n\n<ol>\n<li><p><strong>Stability condition</strong>: Re(a(k)) \u2264 0 for all k \u2260 0\nEnsures that the system does not exhibit exponential growth in time.</p></li>\n<li><p><strong>Dissipation condition</strong>: Re(a(k)) \u2264 -\u03b4 |k|\u00b2 for large |k|\nEnsures sufficient damping at high frequencies to avoid oscillatory instability.</p></li>\n<li><p><strong>Growth condition</strong>: |a(k)| \u2264 C (1 + |k|)^m with m \u2264 4\nEnsures that the symbol does not grow too rapidly with frequency, \nwhich would otherwise cause numerical instability or unphysical amplification.</p></li>\n</ol>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>k_range : tuple or None, optional\n    Specifies the range of frequencies to test in the form (k_min, k_max, N).\n    If None, defaults are used: [-10, 10] with 500 points in 1D, or [-10, 10] \n    with 100 points per axis in 2D.</p>\n\n<p>verbose : bool, default=True\n    If True, prints detailed results of each condition check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>None\n    Output is printed directly to the console for interpretability.</p>\n\n<h2 id=\"notes\">Notes:</h2>\n\n<ul>\n<li>In 2D, the radial frequency |k| = \u221a(kx\u00b2 + ky\u00b2) is used for comparisons.</li>\n<li>The dissipation threshold assumes \u03b4 = 0.01 and p = 2 by default.</li>\n<li>The growth ratio is compared against |k|\u2074; values above 100 indicate rapid growth.</li>\n<li>This function is typically called during solver setup or analysis phase.</li>\n</ul>\n\n<h2 id=\"see-also\">See Also:</h2>\n\n<p>analyze_wave_propagation : For further symbolic and numerical analysis of dispersion.\nplot_symbol : Visualizes the symbol's behavior over the frequency domain.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">k_range</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.analyze_wave_propagation", "modulename": "src", "qualname": "PDESolver.analyze_wave_propagation", "kind": "function", "doc": "<p>Perform a detailed analysis of wave propagation characteristics based on the dispersion relation \u03c9(k).</p>\n\n<p>This method visualizes key wave properties in both 1D and 2D settings:</p>\n\n<ul>\n<li>Dispersion relation: \u03c9(k)</li>\n<li>Phase velocity: v_p(k) = \u03c9(k)/|k|</li>\n<li>Group velocity: v_g(k) = \u2207\u2096 \u03c9(k)</li>\n<li>Anisotropy in 2D (via magnitude of group velocity)</li>\n</ul>\n\n<p>The symbolic dispersion relation 'omega_symbolic' must be defined beforehand.\nThis is typically available only for second-order-in-time equations.</p>\n\n<p>In 1D:\n    Plots \u03c9(k), v_p(k), and v_g(k) over a range of k values.</p>\n\n<p>In 2D:\n    Displays heatmaps of \u03c9(kx, ky), v_p(kx, ky), and |v_g(kx, ky)| over a 2D wavenumber grid.</p>\n\n<p>Raises:\n    AttributeError: If 'omega_symbolic' is not defined, the method exits gracefully with a message.</p>\n\n<p>Side Effects:\n    Generates and displays matplotlib plots.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.plot_symbol", "modulename": "src", "qualname": "PDESolver.plot_symbol", "kind": "function", "doc": "<p>Visualize the spectral symbol L(k) or L(kx, ky) in 1D or 2D.</p>\n\n<p>This method plots the linear operator's symbolic Fourier representation \neither as a function of a single wavenumber k (1D), or two wavenumbers \nkx and ky (2D). The user can choose to display the real part, imaginary part, \nor absolute value of the symbol.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>component : str {'abs', 're', 'im'}\n    Component of the symbol to visualize:</p>\n\n<pre><code>    - 'abs' : absolute value |a(k)|\n    - 're'  : real part Re[a(k)]\n    - 'im'  : imaginary part Im[a(k)]\n</code></pre>\n\n<p>k_range : tuple (kmin, kmax, N), optional\n    Wavenumber range for evaluation:</p>\n\n<pre><code>    - kmin: minimum wavenumber\n    - kmax: maximum wavenumber\n    - N: number of sampling points\n\nIf None, defaults to [-10, 10] with high resolution.\n</code></pre>\n\n<p>cmap : str, optional\n    Colormap used for 2D surface plots. Default is 'viridis'.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<pre><code>ValueError: If the spatial dimension is not 1D or 2D.\n</code></pre>\n\n<p>Notes:\n    - In 1D, the symbol is plotted using a standard 2D line plot.\n    - In 2D, a 3D surface plot is generated with color-mapped height.\n    - Symbol evaluation uses self.L(k), which must be defined and callable.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">component</span><span class=\"o\">=</span><span class=\"s1\">&#39;abs&#39;</span>, </span><span class=\"param\"><span class=\"n\">k_range</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;viridis&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.compute_energy", "modulename": "src", "qualname": "PDESolver.compute_energy", "kind": "function", "doc": "<p>Compute the total energy of the wave equation solution for second-order temporal PDEs. \nThe energy is defined as:\n    E(t) = 1/2 \u222b [ (\u2202\u209cu)\u00b2 + |L\u00b9\u141f\u00b2u|\u00b2 ] dx\nwhere L is the linear operator associated with the spatial part of the PDE,\nand L\u00b9\u141f\u00b2 denotes its square root in Fourier space.</p>\n\n<p>This method supports both 1D and 2D problems and is only meaningful when \nself.temporal_order == 2 (second-order time derivative).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float or None: \n    Total energy at current time step. Returns None if the temporal order is not 2 or if no valid velocity data (v_prev) is available.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Uses FFT-based spectral differentiation to compute the spatial contributions.</li>\n<li>Assumes periodic boundary conditions.</li>\n<li>Handles both real and complex-valued solutions.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.plot_energy", "modulename": "src", "qualname": "PDESolver.plot_energy", "kind": "function", "doc": "<p>Plot the time evolution of the total energy for wave equations. \nVisualizes the energy computed during simulation for both 1D and 2D cases. \nRequires temporal_order=2 and prior execution of compute_energy() during solve().</p>\n\n<p>Parameters:\n    log : bool\n        If True, displays energy on a logarithmic scale to highlight exponential decay/growth.</p>\n\n<p>Notes:\n    - Energy is defined as E(t) = 1/2 \u222b [ (\u2202\u209cu)\u00b2 + |L\u00b9\u2e0d\u00b2u|\u00b2 ] dx\n    - Only available if energy monitoring was activated in solve()\n    - Automatically skips plotting if no energy data is available</p>\n\n<p>Displays:\n    - Time vs. Total Energy plot with grid and legend\n    - Appropriate axis labels and dimensional context (1D/2D)\n    - Logarithmic or linear scaling based on input parameter</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">log</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.show_stationary_solution", "modulename": "src", "qualname": "PDESolver.show_stationary_solution", "kind": "function", "doc": "<p>Display the stationary solution computed by solve_stationary_psiOp.</p>\n\n<p>This method visualizes the solution of a pseudo-differential equation \nsolved in stationary mode. It supports both 1D and 2D spatial domains, \nwith options to display different components of the solution (real, \nimaginary, absolute value, or phase).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>u : ndarray, optional\n    Precomputed solution array. If None, calls solve_stationary_psiOp() \n    to compute the solution.\ncomponent : str, optional {'real', 'imag', 'abs', 'angle'}\n    Component of the complex-valued solution to display:\n    - 'real': Real part\n    - 'imag': Imaginary part\n    - 'abs' : Absolute value (modulus)\n    - 'angle' : Phase (argument)\ncmap : str, optional\n    Colormap used for 2D visualization (default: 'viridis').</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If an invalid component is specified or if the spatial dimension \n    is not supported (only 1D and 2D are implemented).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>In 1D, the solution is displayed using a standard line plot.</li>\n<li>In 2D, the solution is visualized as a 3D surface plot.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">u</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">component</span><span class=\"o\">=</span><span class=\"s1\">&#39;abs&#39;</span>, </span><span class=\"param\"><span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;viridis&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.animate", "modulename": "src", "qualname": "PDESolver.animate", "kind": "function", "doc": "<p>Create an animated plot of the solution evolution over time.</p>\n\n<p>This method generates a dynamic visualization of the stored solution frames\n<code>self.frames</code>. It supports:</p>\n\n<ul>\n<li>1D line animation (unchanged),</li>\n<li>2D surface animation (original behavior, 'surface'),</li>\n<li>2D image animation using imshow (new, 'imshow') which is faster and\noften clearer for large grids.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>component : str, optional, one of {'real', 'imag', 'abs', 'angle'}\n    Which component of the complex field to visualize:\n      - 'real'  : Re(u)\n      - 'imag'  : Im(u)\n      - 'abs'   : |u|\n      - 'angle' : arg(u)\n    Default is 'abs'.</p>\n\n<p>overlay : str or None, optional, one of {'contour', 'front', None}\n    For 2D modes only. If None, no overlay is drawn.\n      - 'contour' : draw contour lines on top (or beneath for 3D surface)\n      - 'front'   : detect and mark wavefronts using gradient maxima\n    Default is 'contour'.</p>\n\n<p>mode : str, optional, one of {'surface', 'imshow'}\n    2D rendering mode. 'surface' keeps the original 3D surface plot.\n    'imshow' draws a 2D raster (faster, often more readable).\n    Default is 'surface' for backward compatibility.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>FuncAnimation\n    A Matplotlib <code>FuncAnimation</code> instance (you can display it in a notebook\n    or save it to file).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>The method uses the same time-mapping logic as before (linear sampling of\nstored frames to animation frames).</li>\n<li>For 'angle' the color scale is fixed between -\u03c0 and \u03c0.</li>\n<li>For other components, color scaling is by default dynamically adapted per\nframe in 'imshow' mode (this avoids extreme clipping if amplitudes vary).</li>\n<li>Overlays are updated cleanly: previous contour/scatter artists are removed\nbefore drawing the next frame to avoid memory/visual accumulation.</li>\n<li>Animation interval is 50 ms per frame (unchanged).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">component</span><span class=\"o\">=</span><span class=\"s1\">&#39;abs&#39;</span>, </span><span class=\"param\"><span class=\"n\">overlay</span><span class=\"o\">=</span><span class=\"s1\">&#39;contour&#39;</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;surface&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.PDESolver.test", "modulename": "src", "qualname": "PDESolver.test", "kind": "function", "doc": "<p>Test the solver against an exact solution.</p>\n\n<p>This method quantitatively compares the numerical solution with a provided exact solution \nat a specified time using either relative or absolute error norms. It supports both \nstationary and time-dependent problems in 1D and 2D. If enabled, it also generates plots \nof the solution, exact solution, and pointwise error.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>u_exact : callable\n    Exact solution function taking spatial coordinates and optionally time as arguments.\nt_eval : float, optional\n    Time at which to compare solutions. For non-stationary problems, defaults to final time Lt.\n    Ignored for stationary problems.\nnorm : str {'relative', 'absolute'}\n    Type of error norm used in comparison.\nthreshold : float\n    Acceptable error threshold; raises an assertion if exceeded.\nplot : bool\n    Whether to display visual comparison plots (default: True).\ncomponent : str {'real', 'imag', 'abs'}\n    Component of the solution to compare and visualize.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    If unsupported dimension is encountered or requested evaluation time exceeds simulation duration.\nAssertionError\n    If computed error exceeds the given threshold.</p>\n\n<h2 id=\"prints\">Prints</h2>\n\n<ul>\n<li>Information about the closest available frame to the requested evaluation time.</li>\n<li>Computed error value and comparison to threshold.</li>\n</ul>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>For time-dependent problems, the solution is extracted from precomputed frames.</li>\n<li>Plots are adapted to spatial dimension: line plots for 1D, image plots for 2D.</li>\n<li>The method ensures consistent handling of real, imaginary, and magnitude components.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">u_exact</span>,</span><span class=\"param\">\t<span class=\"n\">t_eval</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">norm</span><span class=\"o\">=</span><span class=\"s1\">&#39;relative&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">component</span><span class=\"o\">=</span><span class=\"s1\">&#39;real&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.LagrangianHamiltonianConverter", "modulename": "src", "qualname": "LagrangianHamiltonianConverter", "kind": "class", "doc": "<p>Bidirectional converter between Lagrangian and Hamiltonian (Legendre transform),\nwith optional Legendre\u2013Fenchel (convex conjugate) support and robust numeric fallback.</p>\n\n<p>Main API:\n  L_to_H(L_expr, coords, u, p_vars, return_symbol_only=False, force=False,\n         method=\"legendre\", fenchel_opts=None)</p>\n\n<pre><code>- method: \"legendre\" (default), \"fenchel_symbolic\", \"fenchel_numeric\"\n- If method == \"fenchel_numeric\" returns (H_repr, xi_vars, numeric_callable)\n  otherwise returns (H_expr, xi_vars)\n</code></pre>\n"}, {"fullname": "src.LagrangianHamiltonianConverter.L_to_H", "modulename": "src", "qualname": "LagrangianHamiltonianConverter.L_to_H", "kind": "function", "doc": "<p>Convert L(x,u,p) -> H(x,u,xi) with options for generalized Legendre (Fenchel).</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>method: \"legendre\" (default), \"fenchel_symbolic\", \"fenchel_numeric\"</li>\n<li>fenchel_opts: dict with options for numeric fenchel</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">L_expr</span>,</span><span class=\"param\">\t<span class=\"n\">coords</span>,</span><span class=\"param\">\t<span class=\"n\">u</span>,</span><span class=\"param\">\t<span class=\"n\">p_vars</span>,</span><span class=\"param\">\t<span class=\"n\">return_symbol_only</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">force</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;legendre&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">fenchel_opts</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.LagrangianHamiltonianConverter.H_to_L", "modulename": "src", "qualname": "LagrangianHamiltonianConverter.H_to_L", "kind": "function", "doc": "<p>Inverse Legendre (classical). Does not attempt Fenchel inverse.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">H_expr</span>, </span><span class=\"param\"><span class=\"n\">coords</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">xi_vars</span>, </span><span class=\"param\"><span class=\"n\">force</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.HamiltonianSymbolicConverter", "modulename": "src", "qualname": "HamiltonianSymbolicConverter", "kind": "class", "doc": "<p>Symbolic converter between Hamiltonians and formal PDEs (psiOp).</p>\n"}, {"fullname": "src.HamiltonianSymbolicConverter.decompose_hamiltonian", "modulename": "src", "qualname": "HamiltonianSymbolicConverter.decompose_hamiltonian", "kind": "function", "doc": "<p>Decomposes the Hamiltonian into polynomial (local) and non-polynomial (nonlocal) parts.\nThe heuristic treats terms containing sqrt, Abs, or sign as nonlocal.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">H_expr</span>, </span><span class=\"param\"><span class=\"n\">xi_vars</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.HamiltonianSymbolicConverter.hamiltonian_to_symbolic_pde", "modulename": "src", "qualname": "HamiltonianSymbolicConverter.hamiltonian_to_symbolic_pde", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">H_expr</span>, </span><span class=\"param\"><span class=\"n\">coords</span>, </span><span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;schrodinger&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.SymbolGeometry", "modulename": "src", "qualname": "SymbolGeometry", "kind": "class", "doc": "<p>Analyzes the geometric structure of a symbol H(x, \u03be)</p>\n\n<p>This class computes:</p>\n\n<ul>\n<li>Hamiltonian flow (geodesics)</li>\n<li>Jacobian (focusing)</li>\n<li>Caustics (singularities)</li>\n<li>Periodic orbits</li>\n<li>Semiclassical spectrum</li>\n</ul>\n"}, {"fullname": "src.SymbolGeometry.__init__", "modulename": "src", "qualname": "SymbolGeometry.__init__", "kind": "function", "doc": "<p>Initialize with a symbolic Hamiltonian</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>symbol : sympy expression\n    The Hamiltonian H(x, \u03be)\nx_sym, xi_sym : sympy symbols\n    Position and momentum variables</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">symbol</span><span class=\"p\">:</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span>,</span><span class=\"param\">\t<span class=\"n\">x_sym</span><span class=\"p\">:</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">symbol</span><span class=\"o\">.</span><span class=\"n\">Symbol</span>,</span><span class=\"param\">\t<span class=\"n\">xi_sym</span><span class=\"p\">:</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">symbol</span><span class=\"o\">.</span><span class=\"n\">Symbol</span></span>)</span>"}, {"fullname": "src.SymbolGeometry.H", "modulename": "src", "qualname": "SymbolGeometry.H", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry.x_sym", "modulename": "src", "qualname": "SymbolGeometry.x_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry.xi_sym", "modulename": "src", "qualname": "SymbolGeometry.xi_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry.compute_geodesic", "modulename": "src", "qualname": "SymbolGeometry.compute_geodesic", "kind": "function", "doc": "<p>Compute geodesic with Jacobian (for caustics detection)</p>\n\n<p>Solves the augmented system:\ndx/dt = \u2202H/\u2202\u03be\nd\u03be/dt = -\u2202H/\u2202x\ndJ/dt = \u2202\u00b2H/\u2202\u03be\u00b2 J + \u2202\u00b2H/\u2202x\u2202\u03be K  (variational equation)\ndK/dt = -\u2202\u00b2H/\u2202x\u2202\u03be J - \u2202\u00b2H/\u2202x\u00b2 K</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x0, xi0 : float\n    Initial conditions\nt_max : float\n    Final time\nn_points : int\n    Number of points</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Geodesic\n    Complete geodesic information</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">x0</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">xi0</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">t_max</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">n_points</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">500</span></span><span class=\"return-annotation\">) -> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_1d</span><span class=\"o\">.</span><span class=\"n\">Geodesic</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.SymbolGeometry.find_periodic_orbits", "modulename": "src", "qualname": "SymbolGeometry.find_periodic_orbits", "kind": "function", "doc": "<p>Find periodic orbits at fixed energy</p>\n\n<p>Strategy: Sample energy surface H(x,\u03be)=E and look for closed orbits</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>energy : float\n    Target energy level\nx_range, xi_range : tuple\n    Search domain\nn_attempts : int\n    Number of initial conditions to try\ntol_period : float\n    Tolerance for periodicity detection</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>list of PeriodicOrbit\n    Found periodic orbits</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">energy</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">x_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">xi_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_attempts</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">50</span>,</span><span class=\"param\">\t<span class=\"n\">tol_period</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.001</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_1d</span><span class=\"o\">.</span><span class=\"n\">PeriodicOrbit</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.SymbolGeometry.gutzwiller_trace_formula", "modulename": "src", "qualname": "SymbolGeometry.gutzwiller_trace_formula", "kind": "function", "doc": "<p>Gutzwiller trace formula (semiclassical)</p>\n\n<p>Tr[exp(-iHt/\u210f)] \u2248 \u03a3_\u03b3 A_\u03b3 exp(iS_\u03b3/\u210f - i\u03c0\u03bc_\u03b3/2)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>periodic_orbits : list\n    List of periodic orbits\nt_values : array\n    Time values\nhbar : float\n    Reduced Planck constant</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>array\n    Trace as function of time</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">periodic_orbits</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_1d</span><span class=\"o\">.</span><span class=\"n\">PeriodicOrbit</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">t_values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">hbar</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.SymbolGeometry.semiclassical_spectrum", "modulename": "src", "qualname": "SymbolGeometry.semiclassical_spectrum", "kind": "function", "doc": "<p>Extract semiclassical spectrum via Fourier transform of trace</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>periodic_orbits : list\n    Periodic orbits\nhbar : float\n    Reduced Planck constant\nresolution : int\n    Number of points</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Spectrum\n    Spectral information</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">periodic_orbits</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_1d</span><span class=\"o\">.</span><span class=\"n\">PeriodicOrbit</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">hbar</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">resolution</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span></span><span class=\"return-annotation\">) -> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_1d</span><span class=\"o\">.</span><span class=\"n\">Spectrum</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.SymbolVisualizer", "modulename": "src", "qualname": "SymbolVisualizer", "kind": "class", "doc": "<p>Comprehensive visualization of symbol geometry</p>\n\n<p>Produces 15 panels showing:</p>\n\n<ol>\n<li>Hamiltonian surface (3D)</li>\n<li>Energy level sets (phase space foliation)</li>\n<li>Hamiltonian vector field</li>\n<li>Group velocity \u2202H/\u2202\u03be</li>\n<li>Spatial projection (caustics)</li>\n<li>Jacobian (focusing measure)</li>\n<li>Curvature (focusing tendency)</li>\n<li>Energy conservation</li>\n<li>Periodic orbits (phase space)</li>\n<li>Period-energy diagram</li>\n<li>EBK quantization</li>\n<li>Trace formula</li>\n<li>Semiclassical spectrum</li>\n<li>Orbit stability</li>\n<li>Level spacing distribution</li>\n</ol>\n"}, {"fullname": "src.SymbolVisualizer.__init__", "modulename": "src", "qualname": "SymbolVisualizer.__init__", "kind": "function", "doc": "<h2 id=\"parameters\">Parameters</h2>\n\n<p>geometry : SymbolGeometry\n    Initialized geometry engine</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geometry</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_1d</span><span class=\"o\">.</span><span class=\"n\">SymbolGeometry</span></span>)</span>"}, {"fullname": "src.SymbolVisualizer.geo", "modulename": "src", "qualname": "SymbolVisualizer.geo", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolVisualizer.visualize_complete", "modulename": "src", "qualname": "SymbolVisualizer.visualize_complete", "kind": "function", "doc": "<p>Create complete geometric atlas</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x_range, xi_range : tuple\n    Domain limits\ngeodesics_params : list of tuples\n    Each tuple: (x0, xi0, t_max, color)\nE_range : tuple, optional\n    Energy range for spectral analysis\nhbar : float\n    Reduced Planck constant\nresolution : int\n    Grid resolution</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>fig, geodesics, periodic_orbits, spectrum</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">x_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">xi_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">geodesics_params</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">E_range</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">hbar</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">resolution</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.SpectralAnalysis", "modulename": "src", "qualname": "SpectralAnalysis", "kind": "class", "doc": "<p>Additional spectral analysis tools</p>\n"}, {"fullname": "src.SpectralAnalysis.weyl_law", "modulename": "src", "qualname": "SpectralAnalysis.weyl_law", "kind": "function", "doc": "<p>Weyl's law: asymptotic density of states</p>\n\n<p>N(E) ~ (1/2\u03c0\u210f)^d \u00d7 Vol{H(x,p) \u2264 E}</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>energy : float\n    Energy threshold\ndimension : int\n    Phase space dimension\nhbar : float\n    Reduced Planck constant</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    Approximate number of states below energy E</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">energy</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">dimension</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">hbar</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.SpectralAnalysis.analyze_integrability", "modulename": "src", "qualname": "SpectralAnalysis.analyze_integrability", "kind": "function", "doc": "<p>Determine if system is integrable or chaotic via level statistics</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>spacings : array\n    Energy level spacings</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    Statistical measures and classification</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spacings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.SpectralAnalysis.berry_tabor_formula", "modulename": "src", "qualname": "SpectralAnalysis.berry_tabor_formula", "kind": "function", "doc": "<p>Berry-Tabor formula for integrable systems</p>\n\n<p>Smoothed density of states from periodic orbits</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>periodic_orbits : list\n    Periodic orbits\nenergy : float\n    Energy at which to evaluate density</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>float\n    Density of states \u03c1(E)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">periodic_orbits</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_1d</span><span class=\"o\">.</span><span class=\"n\">PeriodicOrbit</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">energy</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.SymbolGeometry2D", "modulename": "src", "qualname": "SymbolGeometry2D", "kind": "class", "doc": "<p>Full geometric and semi-classical analysis of a 2D symbol\nH(x, y, \u03be, \u03b7) with 4D phase space and rigorous caustic treatment</p>\n"}, {"fullname": "src.SymbolGeometry2D.__init__", "modulename": "src", "qualname": "SymbolGeometry2D.__init__", "kind": "function", "doc": "<p>Initialization with complete derivative computation for Jacobian evolution</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>symbol : sympy expression\n    Hamiltonian H(x, y, \u03be, \u03b7)\nx_sym, y_sym : sympy symbols\n    Position coordinates\nxi_sym, eta_sym : sympy symbols\n    Momentum coordinates\nhbar : float\n    Reduced Planck constant (for quantum aspects)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">symbol</span><span class=\"p\">:</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">Expr</span>,</span><span class=\"param\">\t<span class=\"n\">x_sym</span><span class=\"p\">:</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">symbol</span><span class=\"o\">.</span><span class=\"n\">Symbol</span>,</span><span class=\"param\">\t<span class=\"n\">y_sym</span><span class=\"p\">:</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">symbol</span><span class=\"o\">.</span><span class=\"n\">Symbol</span>,</span><span class=\"param\">\t<span class=\"n\">xi_sym</span><span class=\"p\">:</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">symbol</span><span class=\"o\">.</span><span class=\"n\">Symbol</span>,</span><span class=\"param\">\t<span class=\"n\">eta_sym</span><span class=\"p\">:</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">symbol</span><span class=\"o\">.</span><span class=\"n\">Symbol</span>,</span><span class=\"param\">\t<span class=\"n\">hbar</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span>)</span>"}, {"fullname": "src.SymbolGeometry2D.H_sym", "modulename": "src", "qualname": "SymbolGeometry2D.H_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.x_sym", "modulename": "src", "qualname": "SymbolGeometry2D.x_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.y_sym", "modulename": "src", "qualname": "SymbolGeometry2D.y_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.xi_sym", "modulename": "src", "qualname": "SymbolGeometry2D.xi_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.eta_sym", "modulename": "src", "qualname": "SymbolGeometry2D.eta_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.hbar", "modulename": "src", "qualname": "SymbolGeometry2D.hbar", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.dH_dx_sym", "modulename": "src", "qualname": "SymbolGeometry2D.dH_dx_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.dH_dy_sym", "modulename": "src", "qualname": "SymbolGeometry2D.dH_dy_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.dH_dxi_sym", "modulename": "src", "qualname": "SymbolGeometry2D.dH_dxi_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.dH_deta_sym", "modulename": "src", "qualname": "SymbolGeometry2D.dH_deta_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.d2H_dx2_sym", "modulename": "src", "qualname": "SymbolGeometry2D.d2H_dx2_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.d2H_dy2_sym", "modulename": "src", "qualname": "SymbolGeometry2D.d2H_dy2_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.d2H_dxi2_sym", "modulename": "src", "qualname": "SymbolGeometry2D.d2H_dxi2_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.d2H_deta2_sym", "modulename": "src", "qualname": "SymbolGeometry2D.d2H_deta2_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.d2H_dxdy_sym", "modulename": "src", "qualname": "SymbolGeometry2D.d2H_dxdy_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.d2H_dxdxi_sym", "modulename": "src", "qualname": "SymbolGeometry2D.d2H_dxdxi_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.d2H_dxdeta_sym", "modulename": "src", "qualname": "SymbolGeometry2D.d2H_dxdeta_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.d2H_dydxi_sym", "modulename": "src", "qualname": "SymbolGeometry2D.d2H_dydxi_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.d2H_dyeta_sym", "modulename": "src", "qualname": "SymbolGeometry2D.d2H_dyeta_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.d2H_dxideta_sym", "modulename": "src", "qualname": "SymbolGeometry2D.d2H_dxideta_sym", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.Hessian", "modulename": "src", "qualname": "SymbolGeometry2D.Hessian", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolGeometry2D.compute_geodesic", "modulename": "src", "qualname": "SymbolGeometry2D.compute_geodesic", "kind": "function", "doc": "<p>Compute a geodesic with full Jacobian evolution for caustic detection</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x0, y0 : float\n    Initial position\nxi0, eta0 : float\n    Initial momentum\nt_max : float\n    Final time\nn_points : int\n    Number of sampling points</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Geodesic2D\n    Structure containing trajectory and caustic analysis</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">x0</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">y0</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">xi0</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">eta0</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">t_max</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">n_points</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">500</span></span><span class=\"return-annotation\">) -> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_2d</span><span class=\"o\">.</span><span class=\"n\">Geodesic2D</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.SymbolGeometry2D.find_periodic_orbits_2d", "modulename": "src", "qualname": "SymbolGeometry2D.find_periodic_orbits_2d", "kind": "function", "doc": "<p>Search for periodic orbits with Maslov index computation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">energy</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">x_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">y_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">xi_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">eta_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_attempts</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">30</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_2d</span><span class=\"o\">.</span><span class=\"n\">PeriodicOrbit2D</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.SymbolGeometry2D.detect_caustic_structures", "modulename": "src", "qualname": "SymbolGeometry2D.detect_caustic_structures", "kind": "function", "doc": "<p>Advanced caustic structure detection with classification</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">geodesics</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_2d</span><span class=\"o\">.</span><span class=\"n\">Geodesic2D</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">t_fixed</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_2d</span><span class=\"o\">.</span><span class=\"n\">CausticStructure</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.SymbolGeometry2D.compute_phase_space_volume", "modulename": "src", "qualname": "SymbolGeometry2D.compute_phase_space_volume", "kind": "function", "doc": "<p>Monte Carlo estimation of phase space volume for H \u2264 E_max</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">E_max</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">x_range</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">y_range</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">xi_range</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">eta_range</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">n_samples</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">200000</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.SymbolVisualizer2D", "modulename": "src", "qualname": "SymbolVisualizer2D", "kind": "class", "doc": "<p>Complete visualization combining geometric and physical aspects</p>\n"}, {"fullname": "src.SymbolVisualizer2D.__init__", "modulename": "src", "qualname": "SymbolVisualizer2D.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geometry</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_2d</span><span class=\"o\">.</span><span class=\"n\">SymbolGeometry2D</span></span>)</span>"}, {"fullname": "src.SymbolVisualizer2D.geo", "modulename": "src", "qualname": "SymbolVisualizer2D.geo", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.SymbolVisualizer2D.visualize_complete", "modulename": "src", "qualname": "SymbolVisualizer2D.visualize_complete", "kind": "function", "doc": "<p>Create a complete 18-panel visualization combining geometry and physics</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x_range, y_range : tuple\n    Configuration space domain\nxi_range, eta_range : tuple\n    Momentum space domain\ngeodesics_params : list\n    Geodesic parameters: (x0, y0, xi0, eta0, t_max, color)\nE_range : tuple, optional\n    Energy interval for spectral analysis\nhbar : float\n    Reduced Planck constant\nresolution : int\n    Grid resolution</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>fig, geodesics, periodic_orbits, caustics</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">x_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">y_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">xi_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">eta_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">geodesics_params</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">E_range</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">hbar</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">resolution</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">50</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.Utilities2D", "modulename": "src", "qualname": "Utilities2D", "kind": "class", "doc": "<p>Additional analysis tools for 2D systems</p>\n"}, {"fullname": "src.Utilities2D.compute_winding_number", "modulename": "src", "qualname": "Utilities2D.compute_winding_number", "kind": "function", "doc": "<p>Compute winding number around origin</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geo</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_2d</span><span class=\"o\">.</span><span class=\"n\">Geodesic2D</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.Utilities2D.compute_rotation_numbers", "modulename": "src", "qualname": "Utilities2D.compute_rotation_numbers", "kind": "function", "doc": "<p>Compute rotation numbers (\u03c9_x, \u03c9_y)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geo</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_2d</span><span class=\"o\">.</span><span class=\"n\">Geodesic2D</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.Utilities2D.detect_kam_tori", "modulename": "src", "qualname": "Utilities2D.detect_kam_tori", "kind": "function", "doc": "<p>Detect KAM tori from periodic orbits</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">periodic_orbits</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">geometry_2d</span><span class=\"o\">.</span><span class=\"n\">PeriodicOrbit2D</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">tolerance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();